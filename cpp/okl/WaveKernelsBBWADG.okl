#define NGEO   (p_Nvgeo+p_Nfgeo*p_Nfaces) // total number of geometric factors
#define ddot4(a,b)  a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w

// defined in WaveOKL3d (initWave3d)
#if USE_DOUBLE
#define dfloat double
#define dfloat4 double4
#else
#define dfloat float
#define dfloat4 float4
#endif

// polynomial mult, write to global mem
kernel void rk_update_BBWADG(const int K,
			     const int * restrict subtet_ids,
			     const dfloat * restrict CNscale,
			     const dfloat * restrict invC2Nscale,
			     const dfloat4 * restrict Ei_vals,
			     const int4 * restrict Ei_ids,
			     const dfloat4 * restrict EiTr_vals,
			     const int4 * restrict EiTr_ids,
			     const dfloat * restrict cj,
			     const dfloat * restrict c2_bb,
			     dfloat * restrict rhsQ){

  for(int k1=0; k1<(K+p_KblkU-1)/p_KblkU; ++k1; outer0){

    shared dfloat sp[p_KblkU][p_Np];
    shared dfloat sc2[p_KblkU][p_Np];

    // may be too heavy on smem at higher orders here
    // can optimize
    shared dfloat stmp[p_KblkU][p_N2p]; // (2N+1)(2N+2)(2N+3)/6 

    shared dfloat s_cj[p_N+1]; // constants in projection matrix

    exclusive int k, jsk;
    exclusive dfloat rtmp[p_max8Np1D]; // tmp register memory

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){

	k = k1*p_KblkU + k2; // no need for klist here for heterogeneous WADG
	if (k2==0 && i < (p_N+1)){
	  s_cj[i] = cj[i];
	}

	if (k < K){
	  const dfloat CN = CNscale[i];

	  // read in pressure rhs, scale by bb and CN
	  sp[k2][i] = rhsQ[i + k*p_Np*p_Nfields]*CN;
	  sc2[k2][i] = c2_bb[i + k*p_Np]*CN;

	}

        // initialize counter
        jsk = 0;
      }
    }
    barrier(localMemFence);

#if 1
    // ============= polynomial multiplication

    //for (int j = 0; j < p_Np; ++j){
    for (int kk = 0; kk <= p_N; ++kk){
      for (int jj = 0; jj <= p_N-kk; ++jj){
        for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
          for(int i = 0; i < p_Np; ++i; inner0){

            if (k < K){

              // to optimize:
              // - bitpack ints together
              // - reduce loads: increment id when possible instead of reloading
              int id = subtet_ids[i + jsk*p_Np];

              for (int ii = 0; ii <=p_N-jj-kk; ++ii){
                stmp[k2][id] += sc2[k2][jj]*sp[k2][i];
                ++id;
              }
            }

          }

	}
      }
      barrier(localMemFence); // not sure if needed - can use smem atomics?

    } // for (j < p_Np)

    // rescale by 1/C2N
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){
	int isk = i;
	while (isk < p_N2p){
	  const dfloat invC2N = invC2Nscale[isk];
	  stmp[k2][isk] *= invC2N;
	  isk += p_Np;
	}
      }
    }
    barrier(localMemFence);

    // ===================== end polynomial multiplication step
#endif

    // =================== do degree reductions from 2N to N
#if 1
    for (int jj = 0; jj < p_N; ++jj){

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  const int Nj = 2*p_N-jj;
	  int Np_reduce = (Nj+1)*(Nj+2)*(Nj+3)/6;
	  int isk = i;
	  while (isk < Np_reduce){

	    // offset to use 2N degree reduc
	    const int idE = isk + (Nj-1)*p_N2p;
	    const int4 Ei_id = EiTr_ids[idE];
	    const dfloat4 Ei_val = EiTr_vals[idE];

	    rtmp[isk/p_Np] =
	      //rtmp[i] =
	      Ei_val.x*stmp[k2][Ei_id.x] +
	      Ei_val.y*stmp[k2][Ei_id.y] +
	      Ei_val.z*stmp[k2][Ei_id.z] +
	      Ei_val.w*stmp[k2][Ei_id.w];

	    isk += p_Np;
	  }
	}
      }
      barrier(localMemFence);

      // reuse smem to store reduction
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  const int Nj = 2*p_N-jj;
	  const int Np_reduce = (Nj+1)*(Nj+2)*(Nj+3)/6;
	  int isk = i;
	  while (isk < Np_reduce){
	    stmp[k2][isk] = rtmp[isk/p_Np];
            //stmp[k2][isk] = rtmp[i];
	    isk += p_Np;
	  }
	}
      }

    } // =============  end loop over 2N->N degree reduction

    barrier(localMemFence); // ensure stmp has degree reduced results
#endif

    // ============ apply sum of E*E' operators in 2 sweeps

#if 1
    // sweep #1 - degree reduce down from degree N to 0
    for (int jj = 0; jj <= p_N; ++jj){


      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  if (jj==0){

	    // save reduced result to register
	    rtmp[jj] = stmp[k2][i];

	  }else{

	    const int Nj = p_N-jj;
	    const int Np_reduce = (Nj+1)*(Nj+2)*(Nj+3)/6;
	    if (i < Np_reduce){

	      // degree reduce and save to shared
	      const int idE = i + (Nj)*p_N2p; // use (Nj-1) to Nj elevation
	      const int4 Ei_id = Ei_ids[idE];
	      const dfloat4 Ei_val = Ei_vals[idE];

	      //	      if (k==0){
	      //		printf("Ei_id[%d] = %d, %d, %d, %d\n",idE,Ei_id.x,Ei_id.y,Ei_id.z,Ei_id.w);
	      //	      }

	      // save current reduced value to register
	      rtmp[jj] =
		Ei_val.x*stmp[k2][Ei_id.x] +
		Ei_val.y*stmp[k2][Ei_id.y] +
		Ei_val.z*stmp[k2][Ei_id.z] +
		Ei_val.w*stmp[k2][Ei_id.w];

	    } // if i < Np_reduce


	  } // end ifelse

	}
      } // end inner loops

      barrier(localMemFence);

      // reuse smem
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  const int Nj = p_N-jj;
	  const int Np_reduce = (Nj+1)*(Nj+2)*(Nj+3)/6;

	  if (i < Np_reduce){
	    stmp[k2][i] = rtmp[jj];
	    rtmp[jj] *= s_cj[jj]; // scale by coeff after writing to smem
	  }

	}
      }

      barrier(localMemFence);

    } // end loop over j - end degree reduction sweep

#endif

#if 1
    // sweep #2 - elevate up from degree 0 to N.
    for (int jj = 0; jj < p_N; ++jj){

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  // elevate from degree j to j+1
	  const int Nj = jj+1;
	  const int Npj = (Nj+1)*(Nj+2)*(Nj+3)/6;
	  if (i < Npj){
	    // use jth degree elev op = from degree j to j+1
	    const int idE = i + (Nj-1)*p_N2p;
	    const int4 Ei_id = Ei_ids[idE];
	    const dfloat4 Ei_val = Ei_vals[idE];

	    const dfloat val =
	      Ei_val.x*stmp[k2][Ei_id.x] +
	      Ei_val.y*stmp[k2][Ei_id.y] +
	      Ei_val.z*stmp[k2][Ei_id.z] +
	      Ei_val.w*stmp[k2][Ei_id.w];

	    // if j==0, don't accumulate. degree elev + scale by cj
	    if (jj == 0){
	      rtmp[p_N] = val*s_cj[p_N];
	    }else{
	      // rtmp = c_j*E_{N-j}^N applied to coeffs
	      rtmp[p_N-jj] += val;
	    }
	  } // i < Npj
	}
      }

      barrier(localMemFence);

      // copy over result from register
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  const int Nj = jj+1;
	  const int Npj = (Nj+1)*(Nj+2)*(Nj+3)/6;
	  if (i < Npj){
	    stmp[k2][i] = rtmp[p_N-jj];
	  }
	}
      }
      barrier(localMemFence);

    } // loop over j degree elevations

#endif

#if 1
    // add accumulated result to all Np coeffs and write to global mem
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){
	rhsQ[i + k*p_Np*p_Nfields] = rtmp[0] + stmp[k2][i];
      }
    }
#endif
  }// outer 0
}



kernel void rk_update_BBWADGq(const int K,
			      const dfloat4 * restrict ETri_vals,
			      const int4 * restrict ETri_ids,
			      const dfloat4 * restrict ETriTr_vals,
			      const int4 * restrict ETriTr_ids,
			      const int * restrict tri_to_quad_ids, // tri to quad  
			      const dfloat * restrict Vab1D,
			      const dfloat * restrict Vc1D,			      
			      const dfloat * restrict wc2q,
			      dfloat * restrict rhsQ){
  
  for(int k1=0; k1<(K+p_KblkU-1)/p_KblkU; ++k1; outer0){

    shared dfloat sp[p_KblkU][p_Np];
    shared dfloat stmp[p_KblkU][p_Nq1D][p_Nq2]; 
    shared dfloat s_Vq[p_N+1][p_Nq1D]; // quadrature interpolation matrix
    shared dfloat s_Vcq[p_N+1][p_Nq1D];     

    exclusive int k,jsk;
    exclusive dfloat rtmp[p_N+1]; // tmp storage

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){

	k = k1*p_KblkU + k2; // no need for klist here for heterogeneous WADG
	if (k < K){
	  // read in pressure rhs (c2 readin later)
	  const dfloat val = rhsQ[i + k*p_Np*p_Nfields];
	  sp[k2][i] = val;
#if 0
	  if (k==0){
	    printf("p[%d] = %f\n",i,val);
	  }
#endif
	}

	if (k==0 && i < p_Nq2){
	  const int idi = i % p_Nq1D;
	  const int idj = i / p_Nq1D;	  
	  s_Vq[idi][idj] = Vab1D[i];
	  s_Vcq[idi][idj] = Vc1D[i];
	}

	// init counter
	jsk = 0;
      }
    }
    barrier(localMemFence);

    // read tet pts to hex array
    for (int jj = 0; jj <= p_N; ++jj){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  const int Nj = p_N-jj;
	  const int Np_slice = (Nj+1)*(Nj+2)/2;
	  if (k < K && i < Np_slice){

	    stmp[k2][jj][i] = sp[k2][i + jsk];
	    
#if 0
	    if (k==0 && jj==1){
	      dfloat val = stmp[k2][jj][i];
	      printf("stmp[%d][%d] = %f\n",jj,i,val);
	    }
#endif
	    
	    const int Np_slice = (p_N-jj+1)*(p_N-jj+2)/2;
	    jsk += Np_slice;
	  }
	}
      }
    }
    
    // interpolate tet control pts to wedge

    // loop backwards over tri slices, skip base tri slice (done already)
    for(int jj = 0; jj < p_N; ++jj){ 
      
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  const int Nj = jj+1; // elevate from degree i to (i+1)
	  const int Np_slice = (Nj+1)*(Nj+2)/2;
	  if (k < K && i < Np_slice){	    
	    const int idE = i + jj*p_NpTri;
	    const int4 Ei_id = ETri_ids[idE]; // may not want to use float4s...
	    const dfloat4 Ei_val = ETri_vals[idE];
	    
	    // apply successive degree elevation to previous slices
	    for (int j2 = p_N-jj; j2 <= p_N; ++j2){
	      rtmp[j2] = 
		Ei_val.x*stmp[k2][j2][Ei_id.x] +
		Ei_val.y*stmp[k2][j2][Ei_id.y] +
		Ei_val.z*stmp[k2][j2][Ei_id.z];
	    }
	  }
	} //inner0
      }// inner1 

      // make sure reads from stmp are done
      barrier(localMemFence);

      // write back stored values to hex slices
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  const int Nj = jj+1; // elevate from degree i to (i+1)
	  const int Np_slice = (Nj+1)*(Nj+2)/2;

	  if (i < Np_slice){
	    for (int j2 = p_N-jj; j2 <= p_N; ++j2){
	      stmp[k2][j2][i] = rtmp[j2];	      
	    }
	    
	  }
	}
      }
      
    } // loop over jj
    barrier(localMemFence);

    // remap wedge indices to hex indices
    // rtmp should still hold last set of values
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){
       	  
	if (i < p_NpTri){
	  const int tri_to_quad_id = tri_to_quad_ids[i];
	  stmp[k2][0][tri_to_quad_id] = sp[k2][i];
	  for(int jj = 1; jj <= p_N; ++jj){
	    stmp[k2][jj][tri_to_quad_id] = rtmp[jj];
	  }
	}
      }
    }
    
    barrier(localMemFence);

   
    // elevate wedge lines to hex
    for(int jj = 0; jj < p_N; ++jj){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  // start from furthest slice of the wedge
	  // elevate from degree jj to jj+1 
	  if (k < K && i < (p_N+1)*(jj+2)){ // (jj+2) in receiving slice
	    
	    // j2 = reloop over previously elevated slices
	    for (int j2 = p_N-jj; j2 <= p_N; ++j2){
	      const int idslice = i / (jj+2);
	      const int id1D = i % (jj+2);
	      const int id = id1D + j2*(p_N+1); // id for quad
	      
	      int jp1 = jj+1;
	      dfloat a,b;
	      int ida, idb;
	      // if endpoint
	      if (id1D==0 || id1D==(jj+2)){ 
		a = 1.f;
		b = 0.f;
		ida = (id1D==0) ? id : id-1;
		idb = (id1D==0) ? id : id-1;		
	      }else{
		a = (dfloat) id1D / ((dfloat) jp1);
		b = (dfloat) (jp1-id1D) / ((dfloat) jp1);
		ida = id-1;
		idb = id; 
	      }

	      // 1D degree elevation
	      rtmp[j2] = a*stmp[k2][idslice][ida] + b*stmp[k2][idslice][idb];
	      
	    } // j2 loop	    
	  } // if k < K
	  
	}
      }
      barrier(localMemFence);

      // reuse smem
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  // write out all slices
	  for (int j2 = p_N-jj; j2 <= p_N; ++j2){	  
	    if (i < (p_N+1)*(jj+2)){
	      const int idslice = i / (jj+2);
	      const int id1D = i % (jj+2);
	      const int id = id1D + j2*(p_N+1); // id for quad
	      
	      stmp[k2][idslice][id] = rtmp[j2];	      
	    }
	  }
	}
      }
      
    } // hex jj loop

#if 1
    // hex printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_Nq2){
	    dfloat val = stmp[k2][j][i];
	    printf("hex stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif   

    // loop over ab slices
    for (int jj = 0; jj <= p_N; ++jj){

      // apply first TP operator
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){

	    const int idi = i % (p_N+1);
	    const int idj = i / (p_N+1);
	    
	    dfloat val = 0.f;
	    for (int j = 0; j < (p_N+1); ++j){
	      val += s_Vq[idi][j] * stmp[k2][jj][j + idj*(p_N+1)];
	    }
	    rtmp[jj] = val;
	    
	  }
	}
      }

      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){
	    stmp[k2][jj][i] = rtmp[jj];
	  }
	}
      }
      barrier(localMemFence);

      // apply second TP operator
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){
	    const int idi = i % (p_N+1);
	    const int idj = i / (p_N+1);
	    const int id = idj + idi * (p_N+1); // transpose slice
	    
	    dfloat val = 0.f;
	    for (int j = 0; j < (p_N+1); ++j){
	      //val += s_Vq[idi][idj] * stmp[k2][jj][id];
	      val += s_Vq[idi][j] * stmp[k2][jj][idj + j*(p_N+1)];
	    }
	    rtmp[jj] = val;
	  }
	}
      }

      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){
	    stmp[k2][jj][i] = rtmp[jj];
	  }
	}
      }
      barrier(localMemFence);      
      
    } // jj loop

#if 0
    // hex printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_Nq2){
	    dfloat val = stmp[k2][j][i];
	    printf("hex ab stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif

    // apply vertical TP interp using stored register values
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){

	if (k < K && i < p_Nq2){
	  // loop thru slices
	  for (int jj = 0; jj <= p_N; ++jj){	  

	    const int idi = i % (p_N+1);
	    const int idj = i / (p_N+1);
	    
	    const int id = i + jj*p_Nq2 + p_Nq3*k;
	    const dfloat c2q = wc2q[id];
	    
	    dfloat val = 0.f;
	    for (int j = 0; j < (p_N+1); ++j){
	      val += s_Vcq[jj][j]*rtmp[j];
	    }

	    if (k==0){
	      dfloat v = stmp[k2][jj][i];
	      printf("val = %f, c2q(%d) = %f\n",val,id,c2q);
	    }
	    stmp[k2][jj][i] = val * c2q;
	  }
	}
      }
    }

#if 0
    // hex printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_Nq2){
	    dfloat val = stmp[k2][j][i];
	    printf("hex c quad stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif

    // multiply by Vq^T
    for (int jj = 0; jj <= p_N; ++jj){ // over each slice
      
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){

	    const int idi = i % (p_N+1);
	    const int idj = i / (p_N+1);
	    
	    dfloat val = 0.f;
	    // transpose VqT
	    for (int j = 0; j < (p_N+1); ++j){
	      val += s_Vq[j][idi] * stmp[k2][jj][j + idj*(p_N+1)];
	    }
	    rtmp[jj] = val;
	    
	  }
	}
      }
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){
	    stmp[k2][jj][i] = rtmp[jj];
	  }
	}
      }
      barrier(localMemFence);

      // apply second TP transposed operator
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){
	    const int idi = i % (p_N+1);
	    const int idj = i / (p_N+1);
	    const int id = idj + idi * (p_N+1); // transpose slice
	    
	    dfloat val = 0.f;
	    for (int j = 0; j < (p_N+1); ++j){
	      val += s_Vq[j][idi] * stmp[k2][jj][idj + j*(p_N+1)];
	    }
	    rtmp[jj] = val;
	  }
	}
      }
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k < K && i < p_Nq2){
	    stmp[k2][jj][i] = rtmp[jj];
	  }
	}
      }
      barrier(localMemFence);
      
     
    } // jj loop


    // apply vertical TP interp using stored register values
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){

	if (k < K && i < p_Nq2){
	  // loop thru slices
	  for (int jj = 0; jj <= p_N; ++jj){	  

	    const int idi = i % (p_N+1);
	    const int idj = i / (p_N+1);
	    
	    const int id = i + jj*p_Nq2 + p_Nq3*k;
	    const dfloat c2q = wc2q[id];
	    
	    dfloat val = 0.f;
	    for (int j = 0; j < (p_N+1); ++j){
	      val += s_Vcq[j][jj]*rtmp[j];
	    }

	    stmp[k2][jj][i] = val;
	    
	  } // jj loop

	  /*
	  // prestore in rtmp in order to switch from quad/hex to tri/wedge ids
	  const int idslice = i / (p_N+1);
	  const int id = i % (p_N+1);	  
	  rtmp[0] = stmp[k2][idslice][id];
	  */
	}
      }
    }
    
#if 1
    // hex printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_Nq2){
	    dfloat val = stmp[k2][j][i];
	    printf("hex c integrated stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif


#if 1

    // reduce hex to wedge 
    for(int jj = 0; jj < p_N; ++jj){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  // start from furthest slice of the wedge
	  // reduce from p_N-jj+1 nodes to (p_N-jj) nodes
	  if (k < K && i < (p_N+1)*(p_N-jj)){ // (p_N-jj) nodes in receiving line
	    
	    // j2 = reloop over previously elevated slices
	    for (int j2 = jj+1; j2 <= p_N; ++j2){
	      const int idslice = i / (p_N-jj);

	      const int id1D = i % (p_N-jj);
	      const int id = id1D + j2*(p_N+1); // id for quad
	      
	      int Njp1 = p_N-jj;

	      int ida = id;
	      int idb = id + 1;
	      dfloat a = (dfloat) (p_N-id1D) / ((dfloat) Njp1);
	      dfloat b = (dfloat) (id1D+1) / ((dfloat) Njp1);
	      if (id1D==0 || id1D==(p_N-jj)){ // if endpoint
		const dfloat endval = ((dfloat) id1D+1) / ((dfloat) Njp1);
		a = (id1D==0) ? 1.f : endval;
		b = (id1D==0) ? endval : 1.f;
	      }
	      
	      // 1D degree elevation
	      rtmp[j2] = a*stmp[k2][idslice][ida] + b*stmp[k2][idslice][idb];
	      /*
	      if (k==0 && j2==1){
		dfloat val1 = stmp[k2][idslice][ida];
		dfloat val2 = stmp[k2][idslice][idb];		
		printf("reducing from %d to %d: slice = %d, node %d, jj = %d, j2 = %d, val1,2 = %f, %f, c1,2 = %f, %f\n", p_N-jj+1, p_N-jj, idslice,id1D, jj,j2, val1,val2,a,b);
	      }
	      */
	    } // j2 loop	    
	  } // if k < K
	  
	}
      }
      barrier(localMemFence);

      // reuse smem
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  // write out all slices
	  for (int j2 = jj+1; j2 <= p_N; ++j2){	  
	    if (i < (p_N+1)*(p_N-jj)){
	      const int idslice = i / (p_N-jj);

	      const int id1D = i % (p_N-jj);
	      const int id = id1D + j2*(p_N+1); // id for quad
	      
	      stmp[k2][idslice][id] = rtmp[j2];	      
	    }
	  }
	}
      }
      
    } // hex jj loop
#endif

#if 1
    // hex printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_Nq2){
	    dfloat val = stmp[k2][j][i];
	    printf("hex integrated wedge stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif 

    // remap hex indices to wedge indices
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){	
	if (i < p_NpTri){
	  const int tri_to_quad_id = tri_to_quad_ids[i];
	  for(int jj = 0; jj <= p_N; ++jj){
	    rtmp[jj] = stmp[k2][jj][tri_to_quad_id];
	  }
	}
      }
    }   
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){	
	if (i < p_NpTri){
	  for(int jj = 0; jj <= p_N; ++jj){
	    stmp[k2][jj][i] = rtmp[jj];
	  }
	}
      }
    }    


#if 1
    //wedge printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_NpTri){
	    dfloat val = stmp[k2][j][i];
	    printf("wedge stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif 
    
#if 1
    // loop backwards over tri slices, skip base tri slice (done already)
    for(int jj = 0; jj < p_N; ++jj){ 
      
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){
	  
	  const int Nj = p_N - jj - 1; // reduce from degree N-jj to N-jj-1
	  const int Np_slice = (Nj+1)*(Nj+2)/2;	    
	  if (k < K && i < Np_slice){	    
	    
	    const int idE = i + (p_N-1-jj)*p_NpTri;
	    const int4 Ei_id = ETriTr_ids[idE]; // may not want to use float4s...
	    const dfloat4 Ei_val = ETriTr_vals[idE];
	    
	    // apply successive degree reduction to previous slices
	    for (int j2 = jj+1; j2 <= p_N; ++j2){
	      rtmp[j2] = 
		Ei_val.x*stmp[k2][j2][Ei_id.x] +
		Ei_val.y*stmp[k2][j2][Ei_id.y] +
		Ei_val.z*stmp[k2][j2][Ei_id.z];
	    }
	  }
	} //inner0
      }// inner1 

      // make sure reads from stmp are done
      barrier(localMemFence);

      // write back stored values to hex slices
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int i = 0; i < p_Np; ++i; inner0){

	  const int Nj = p_N-jj-1; 
	  const int Np_slice = (Nj+1)*(Nj+2)/2;
	  if (i < Np_slice){
	    for (int j2 = jj+1; j2 <= p_N; ++j2){
	      stmp[k2][j2][i] = rtmp[j2];	      
	    }
	    
	  }
	}
      }
      
    } // loop over jj
    barrier(localMemFence);
#endif

#if 1
    // tet printout
    for (int j = 0; j <= p_N; ++j){
      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for (int i = 0; i < p_Np; ++i; inner0){
	  if (k==0 && i < p_NpTri){
	    dfloat val = stmp[k2][j][i];
	    printf("tet integrated wedge stmp[%d][%d] = %f\n",j,i,val);
	  }
	}
      }
    } 
#endif 
    
    
  } // outer0
}



// Nq loop
kernel void mult_quad(const int K,
		      const dfloat * restrict Vq,
		      const dfloat * restrict Pq,
		      const dfloat * restrict Jq,
		      const dfloat * restrict c2q,
		      const dfloat fa,
		      const dfloat fb,
		      const dfloat fdt,
		      dfloat * restrict rhsQ,
		      dfloat * restrict resQ,
		      dfloat * restrict Q){

  for(int k1=0; k1<(K+p_KblkU-1)/p_KblkU; ++k1; outer0){

    shared dfloat sp[p_KblkV][p_Nq_reduced];

    exclusive dfloat rpq;
    exclusive int k;

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int n = 0; n < p_Nq_reduced; ++n; inner0){

	k = k1*p_KblkU + k2; // no need for klist here for heterogeneous WADG

	// initialize register vars
	rpq = 0.f;

	if (k < K && n < p_Np){
	  const int id = n + k*p_Np*p_Nfields;
	  sp[k2][n] = rhsQ[id];
	}

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int n = 0; n < p_Nq_reduced; ++n; inner0){

	if (k < K){

	  // prefetch
	  rpq = 0.f;
	  for (int j = 0; j < p_Np; ++j){

	    const dfloat Vq_ij = Vq[n + j*p_Nq_reduced];
	    rpq += Vq_ij * sp[k2][j];
	  }
	}
      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int n = 0; n < p_Nq_reduced; ++n;inner0){

	if (k < K){

          const dfloat c2 = c2q[n + k*p_Nq_reduced];
	  sp[k2][n] = rpq * c2;

	}
      } // inner0
    } // inner1
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int n = 0; n < p_Nq_reduced; ++n;inner0){

	if (k < K && n < p_Np){

	  dfloat rp = 0.f;
	  for (int j = 0; j < p_Nq_reduced; ++j){

	    const dfloat Pq_ij = Pq[n + j*p_Np];

	    // accumulate into private vars
	    rp += Pq_ij * sp[k2][j];
	  }

	  rhsQ[n + k*p_Np*p_Nfields] = rp;
	  /*
	  dfloat resx,resy,resz,resw;
	  int id = n + k*p_Np*p_Nfields;
	  resx = resQ[id]; id += p_Np;
	  resy = resQ[id]; id += p_Np;
	  resz = resQ[id]; id += p_Np;
	  resw = resQ[id];

	  resx = fa*resx + fdt*rp;
	  resy = fa*resy + fdt*ru;
	  resz = fa*resz + fdt*rv;
	  resw = fa*resw + fdt*rw;

	  id = n + k*p_Np*p_Nfields;
	  resQ[id] = resx; id += p_Np;
	  resQ[id] = resy; id += p_Np;
	  resQ[id] = resz; id += p_Np;
	  resQ[id] = resw;

	  id = n + k * p_Np * p_Nfields;
	  Q[id] += fb*resx; id += p_Np;
	  Q[id] += fb*resy; id += p_Np;
	  Q[id] += fb*resz; id += p_Np;
	  Q[id] += fb*resw;
	  */
	}

      } // inner 0
    } // inner1
  }// outer 0
}














/*
// for testing - unfinished
kernel void hexInterp(const int K,
		      const dfloat * restrict Vq1D,
		      const dfloat * c2q,
		      dfloat * Qtmp){
  for(int k1=0; k1<(K+p_KblkU-1)/p_KblkU; ++k1; outer0){

    shared dfloat sp[p_KblkU][p_Nq3];
    shared dfloat sc2[p_KblkU][p_Nq3];
    shared dfloat sVq[p_Nq2];

    shared dfloat sprod[p_KblkV][p_Nq3];
    exclusive int k;

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Nq3; ++i; inner0){

	k = k1*p_KblkU + k2; // no need for klist here for heterogeneous WADG

	if (k < K ){
	  int id = i + k*p_Nq3*p_Nfields;

	  // read in pressure rhs, scale by bb
	  sc2[k2][i] = c2q[i + k*p_Np];
	  sp[k2][i] = Qtmp[id];

	  // read in op to smem
	  if (k2==0 && i < p_Nq2){
	    sVq[i] = Vq1D[i];
	  }
	}
      }
    }
    barrier(localMemFence);

    // do TP interp
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Nq3; ++i; inner0){
	// ...
      }
    }

  }

}

// to compare with non-slabbed
kernel void hexInterpSlab(const int K,
			  const dfloat * restrict Vq1D,
			  dfloat * Qtmp){

}
*/
/*
kernel void BBtetToHex(const int K,
		       const dfloat * restrict Evals,
		       const int * restrict Eids,
		       const dfloat * restrict rhsQ,
		       const dfloat * restrict c2_bb,
		       dfloat * restrict Qtmp){

  for(int k1=0; k1<(K+p_KblkU-1)/p_KblkU; ++k1; outer0){

    shared dfloat sp[p_KblkV][p_Np];
    shared dfloat sc2[p_KblkV][p_Np];

    // may be too heavy on smem at higher orders here
    // can optimize
    shared dfloat sprod[p_KblkV][p_N2p]; // (2N+1)(2N+2)(2N+3)/6
    exclusive int k;

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int i = 0; i < p_Np; ++i; inner0){

	k = k1*p_KblkU + k2; // no need for klist here for heterogeneous WADG

	if (k < K ){
	  int id = i + k*p_Np*p_Nfields;

	  // read in pressure rhs, scale by bb
	  sp[k2][i] = rhsQ[id];
	  sc2[k2][i] = c2_bb[i + k*p_Np];
	}
      }
    }
    barrier(localMemFence);

  }
}
*/
