// unroll 
// unsigned int
// unroll LIFT by 4
// reuse shared, remember barrier
// __ldg

#define NGEO   (p_Nvgeo+p_Nfgeo*p_Nfaces) // total number of geometric factors
#define ddot4(a,b)  a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w

// defined in WaveOKL3d (initWave3d)
#if USE_DOUBLE
#define dfloat double
#define dfloat4 double4
#else
#define dfloat float
#define dfloat4 float4
#endif


// ========================= WADGed nodal kernels ==========================

kernel void rk_volume_WADG(const int K,
			   const int * restrict Klist,
			   const dfloat * restrict vgeoq,
			   const dfloat * restrict Jq,
			   const dfloat * restrict Vrq,
			   const dfloat * restrict Vsq,
			   const dfloat * restrict Vtq,
			   const dfloat * restrict Pq,
			   const dfloat * restrict Q,
			   dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkV-1)/p_KblkV; ++k1; outer0){

    shared dfloat sp[p_KblkV][p_Np];
    shared dfloat su[p_KblkV][p_Np];
    shared dfloat sv[p_KblkV][p_Np];
    shared dfloat sw[p_KblkV][p_Np];

#define doubleBuffer 0

#if doubleBuffer==1
    // store intermediate results
    shared dfloat sdU[p_KblkV][p_Np];
    shared dfloat spx[p_KblkV][p_Np];
    shared dfloat spy[p_KblkV][p_Np];
    shared dfloat spz[p_KblkV][p_Np];
#else

#define sdU sp
#define spx su
#define spy sv
#define spz sw
#endif
    
    exclusive dfloat rdivU, rdpdx, rdpdy, rdpdz;
    exclusive int k, kindex;
    exclusive dfloat dpdx, dpdy, dpdz, divU, J;
    // prefetch

    
    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){

      // loop over nodes
      for(int n=0; n<p_Np; ++n;inner0){

	kindex = k1*p_KblkV + k2; k = Klist[kindex];
	//kindex = k1*p_KblkV + k2; k = kindex; // no list - just go thru all elems

	if (kindex < K){

	  // load p into shared memory for element k
	  int id = n + k*p_Np*p_Nfields;
	  sp[k2][n] = Q[id]; id += p_Np;
	  su[k2][n] = Q[id]; id += p_Np;
	  sv[k2][n] = Q[id]; id += p_Np;
	  sw[k2][n] = Q[id];

	}
	// initialize exclusive vars
	rdivU = 0.f;
	rdpdx = 0.f;
	rdpdy = 0.f;
	rdpdz = 0.f;
      }
    }

    barrier(localMemFence);

    for (int block = 0; block < (p_Nq+p_Np-1)/p_Np; ++block){
      for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
	for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes
	  
	  //for (int block = 0; block < (p_Nq+p_Np-1)/p_Np; ++block){

	  const int i = n + block*p_Np;
	 
	  if (kindex < K && i < p_Nq){

	    int id = i + p_Nq * p_Nvgeo * k;
	    const dfloat rx = vgeoq[id]; id += p_Nq;
	    const dfloat sx = vgeoq[id]; id += p_Nq;
	    const dfloat tx = vgeoq[id]; id += p_Nq;
	    const dfloat ry = vgeoq[id]; id += p_Nq;
	    const dfloat sy = vgeoq[id]; id += p_Nq;
	    const dfloat ty = vgeoq[id]; id += p_Nq;
	    const dfloat rz = vgeoq[id]; id += p_Nq;
	    const dfloat sz = vgeoq[id]; id += p_Nq;
	    const dfloat tz = vgeoq[id];
	    J = Jq[i + k*p_Nq];

#if 1
	    dfloat dpdr = 0.f, dpds = 0.f, dpdt = 0.f;
	    dfloat dudr = 0.f, duds = 0.f, dudt = 0.f;
	    dfloat dvdr = 0.f, dvds = 0.f, dvdt = 0.f;
	    dfloat dwdr = 0.f, dwds = 0.f, dwdt = 0.f;
#endif
	    dpdx = 0.f; dpdy = 0.f; dpdz = 0.f; divU = 0.f;
	    
	    occaUnroll(p_Np)
	    for(int m = 0; m < p_Np; ++m){ // ILP

	      const dfloat pm = sp[k2][m];
	      const dfloat um = su[k2][m];
	      const dfloat vm = sv[k2][m];
	      const dfloat wm = sw[k2][m];
#if 1
	      const dfloat Dr_m = Vrq[i + m*p_Nq];
	      dpdr += Dr_m*pm;
	      dudr += Dr_m*um;
	      dvdr += Dr_m*vm;
	      dwdr += Dr_m*wm;
	      
	      const dfloat Ds_m = Vsq[i + m*p_Nq];
	      dpds += Ds_m*pm;
	      duds += Ds_m*um;
	      dvds += Ds_m*vm;
	      dwds += Ds_m*wm;

	      const dfloat Dt_m = Vtq[i + m*p_Nq];
	      dpdt += Dt_m*pm;
	      dudt += Dt_m*um;
	      dvdt += Dt_m*vm;
	      dwdt += Dt_m*wm;
#else
	      const int mid = i+m*p_Nq;
	      const dfloat dr = Vrq[mid], ds = Vsq[mid], dt = Vtq[mid];
	      const dfloat dx = rx*dr+sx*ds+tx*dt;
	      const dfloat dy = ry*dr+sy*ds+ty*dt;
	      const dfloat dz = rz*dr+sz*ds+tz*dt;

	      dpdx += dx*pm;
	      dpdy += dy*pm;
	      dpdz += dz*pm;
	      divU += dx*um+dy*vm+dz*wm;
#endif	      
	    }

#if 1
	    dpdx = rx*dpdr + sx*dpds + tx*dpdt;
	    dpdy = ry*dpdr + sy*dpds + ty*dpdt;
	    dpdz = rz*dpdr + sz*dpds + tz*dpdt;

	    divU =
	      rx*dudr + sx*duds + tx*dudt +
	      ry*dvdr + sy*dvds + ty*dvdt +
	      rz*dwdr + sz*dwds + tz*dwdt;
#endif
	    
#if doubleBuffer!=1
	  }
	}
      }
      
      barrier(localMemFence);
      
      for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
	for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	  const int i = n + block*p_Np;

	  if (kindex < K && i < p_Nq){
#endif	    
	    spx[k2][n] = dpdx * J;
	    spy[k2][n] = dpdy * J;
	    spz[k2][n] = dpdz * J;	   	    
	    sdU[k2][n] = divU * J;
	    
	  } // k < K
	}
      }
      
      // sync all threads even with k >= K
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
	for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	  if (kindex < K){
	    const int Nt = min((int)p_Np,(int)p_Nq - (int)block*p_Np);

	    for(int m = 0; m < Nt; ++m){ // ILP
	      const int j = m + block*p_Np; // index into next cols
	      const dfloat Pq_m = Pq[n + j*p_Np];

	      rdivU += Pq_m * sdU[k2][m];
	      rdpdx += Pq_m * spx[k2][m];
	      rdpdy += Pq_m * spy[k2][m];
	      rdpdz += Pq_m * spz[k2][m];
	    }

	  } // k < K
	} //inner0
      } // inner1
    } // for loop over blocks p_NqDivNp

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	if (kindex < K){
	  int id = n + k*p_Np*p_Nfields;
	  rhsQ[id] = -rdivU; id += p_Np;
	  rhsQ[id] = -rdpdx; id += p_Np;
	  rhsQ[id] = -rdpdy; id += p_Np;
	  rhsQ[id] = -rdpdz;

	}

      } // inner loop
    }// k2 blk

  }
}

#undef sdU
#undef spx
#undef spy
#undef spz


kernel void rk_volume_WADG_skew_combine(const int K,
					const int * restrict Klist,
					const dfloat * restrict vgeoq,
					const dfloat * restrict Jq,
					const dfloat * restrict Vq,
					const dfloat * restrict Vrq,
					const dfloat * restrict Vsq,
					const dfloat * restrict Vtq,
					const dfloat * restrict Pq,
					const dfloat * restrict Prq,
					const dfloat * restrict Psq,
					const dfloat * restrict Ptq,
					const dfloat * restrict Q,
					dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkV-1)/p_KblkV; ++k1; outer0){

    shared dfloat sp[p_KblkV][p_Np];
    shared dfloat su[p_KblkV][p_Np];
    shared dfloat sv[p_KblkV][p_Np];
    shared dfloat sw[p_KblkV][p_Np];

    // store intermediate results
    shared dfloat sUr[p_KblkV][p_Np];
    shared dfloat sUs[p_KblkV][p_Np];
    shared dfloat sUt[p_KblkV][p_Np];
    shared dfloat spx[p_KblkV][p_Np];
    shared dfloat spy[p_KblkV][p_Np];
    shared dfloat spz[p_KblkV][p_Np];

    exclusive dfloat rdivU, rdpdx, rdpdy, rdpdz;
    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){

      // loop over nodes
      for(int n=0; n<p_Np; ++n;inner0){

	kindex = k1*p_KblkV + k2; k = Klist[kindex];
	//kindex = k1*p_KblkV + k2; k = kindex; // no list - just go thru all elems

	if (kindex < K){

	  // load p into shared memory for element k
	  int id = n + k*p_Np*p_Nfields;
	  sp[k2][n] = Q[id]; id += p_Np;
	  su[k2][n] = Q[id]; id += p_Np;
	  sv[k2][n] = Q[id]; id += p_Np;
	  sw[k2][n] = Q[id];

	}
	// initialize exclusive vars
	rdivU = 0.f;
	rdpdx = 0.f;
	rdpdy = 0.f;
	rdpdz = 0.f;
      }
    }
    barrier(localMemFence);

    for (int block = 0; block < (p_Nq+p_Np-1)/p_Np; ++block){
      for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
	for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	  const int i = n + block*p_Np;

	  if (kindex < K && i < p_Nq){

	    // prefetch
	    int id = i + p_Nq * p_Nvgeo * k;
	    const dfloat rx = vgeoq[id]; id += p_Nq;
	    const dfloat sx = vgeoq[id]; id += p_Nq;
	    const dfloat tx = vgeoq[id]; id += p_Nq;
	    const dfloat ry = vgeoq[id]; id += p_Nq;
	    const dfloat sy = vgeoq[id]; id += p_Nq;
	    const dfloat ty = vgeoq[id]; id += p_Nq;
	    const dfloat rz = vgeoq[id]; id += p_Nq;
	    const dfloat sz = vgeoq[id]; id += p_Nq;
	    const dfloat tz = vgeoq[id];
	    const dfloat J = Jq[i + k*p_Nq];

	    dfloat dpdr = 0.f, dpds = 0.f, dpdt = 0.f;
	    dfloat uq = 0.f, vq = 0.f, wq = 0.f;
	    for(int m = 0; m < p_Np; ++m){ // ILP

	      const dfloat pm = sp[k2][m];
	      const dfloat um = su[k2][m];
	      const dfloat vm = sv[k2][m];
	      const dfloat wm = sw[k2][m];

	      const dfloat Dr_m = Vrq[i + m*p_Nq];
	      const dfloat Ds_m = Vsq[i + m*p_Nq];
	      const dfloat Dt_m = Vtq[i + m*p_Nq];

	      const dfloat Vq_m = Vq[i + m*p_Nq];
	      uq += Vq_m * um;
	      vq += Vq_m * vm;
	      wq += Vq_m * wm;

	      dpdr += Dr_m*pm;
	      dpds += Ds_m*pm;
	      dpdt += Dt_m*pm;

	    }

	    const dfloat dpdx = rx*dpdr + sx*dpds + tx*dpdt;
	    spx[k2][n] = dpdx * J;
	    const dfloat dpdy = ry*dpdr + sy*dpds + ty*dpdt;
	    spy[k2][n] = dpdy * J;
	    const dfloat dpdz = rz*dpdr + sz*dpds + tz*dpdt;
	    spz[k2][n] = dpdz * J;

	    sUr[k2][n] = (uq * rx + vq * ry + wq * rz)*J;
	    sUs[k2][n] = (uq * sx + vq * sy + wq * sz)*J;
	    sUt[k2][n] = (uq * tx + vq * ty + wq * tz)*J;

	  } // k < K
	}
      }
      // sync all threads even with k >= K
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
	for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	  if (kindex < K){
	    const int Nt = min(p_Np,p_Nq - block*p_Np);
	    for(int m = 0; m < Nt; ++m){ // ILP
	      const int j = m + block*p_Np; // index into next cols
	      const dfloat Prq_m = Prq[n + j*p_Np];
	      const dfloat Psq_m = Psq[n + j*p_Np];
	      const dfloat Ptq_m = Ptq[n + j*p_Np];
	      const dfloat Pq_m = Pq[n + j*p_Np];

	      rdivU += Prq_m * sUr[k2][m];
	      rdivU += Psq_m * sUs[k2][m];
	      rdivU += Ptq_m * sUt[k2][m];

	      rdpdx += Pq_m * spx[k2][m];
	      rdpdy += Pq_m * spy[k2][m];
	      rdpdz += Pq_m * spz[k2][m];
	    }

	  } // k < K
	} //inner0
      } // inner1
    } // for loop over blocks p_NqDivNp

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	if (kindex < K){
	  int id = n + k*p_Np*p_Nfields;
	  rhsQ[id] = rdivU; id += p_Np;
	  rhsQ[id] = -rdpdx; id += p_Np;
	  rhsQ[id] = -rdpdy; id += p_Np;
	  rhsQ[id] = -rdpdz;

	}

      } // inner loop
    }// k2 blk

  }
}

kernel void kernel_write_vol_quad4(const int K,
                                   const int * restrict Klist,
                                   const dfloat * restrict vgeoq,
                                   const dfloat * restrict Jq,
                                   const dfloat * restrict Vq,
                                   const dfloat * restrict Vrq,
                                   const dfloat * restrict Vsq,
                                   const dfloat * restrict Vtq,
                                   const dfloat * restrict Q,
                                   dfloat * restrict Qtmp){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkQ-1)/p_KblkQ; ++k1; outer0){

    shared dfloat sp[p_KblkQ][p_Np];
    shared dfloat su[p_KblkQ][p_Np];
    shared dfloat sv[p_KblkQ][p_Np];
    shared dfloat sw[p_KblkQ][p_Np];

    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkQ; ++k2; inner1){

      // loop over nodes
      for(int nt=0; nt<p_ceilNq; ++nt; inner0){

	kindex = k1*p_KblkQ + k2;
	k = Klist[kindex];

	if (kindex < K && nt < p_Np){
	  // load p into shared memory for element k
	  int id = nt + k*p_Np*p_Nfields;
	  sp[k2][nt] = Q[id]; id += p_Np;
	  su[k2][nt] = Q[id]; id += p_Np;
	  sv[k2][nt] = Q[id]; id += p_Np;
	  sw[k2][nt] = Q[id];
	}

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkQ; ++k2; inner1){
      for(int nt = 0; nt<p_ceilNq; ++nt;inner0){

        if (kindex < K){
          int n = nt;
          while (n < p_Nq){
            // prefetch
            int id = n + p_Nq * p_Nvgeo * k;
            const dfloat rxq = vgeoq[id]; id += p_Nq;
            const dfloat sxq = vgeoq[id]; id += p_Nq;
            const dfloat txq = vgeoq[id]; id += p_Nq;
            const dfloat ryq = vgeoq[id]; id += p_Nq;
            const dfloat syq = vgeoq[id]; id += p_Nq;
            const dfloat tyq = vgeoq[id]; id += p_Nq;
            const dfloat rzq = vgeoq[id]; id += p_Nq;
            const dfloat szq = vgeoq[id]; id += p_Nq;
            const dfloat tzq = vgeoq[id];
            const dfloat Jqn = Jq[n + k*p_Nq];

            // write out grad p, div U
            dfloat pr = 0.f, ps = 0.f, pt = 0.f;
            dfloat ur = 0.f, us = 0.f, ut = 0.f;
            dfloat vr = 0.f, vs = 0.f, vt = 0.f;
            dfloat wr = 0.f, ws = 0.f, wt = 0.f;

            for (int j = 0; j < p_Np; ++j){
              const dfloat pj = sp[k2][j];
              const dfloat uj = su[k2][j];
              const dfloat vj = sv[k2][j];
              const dfloat wj = sw[k2][j];

              const dfloat Vr_ij = Vrq[n + j*p_Nq];
              pr += Vr_ij * pj;
              ur += Vr_ij * uj;
              vr += Vr_ij * vj;
              wr += Vr_ij * wj;

              const dfloat Vs_ij = Vsq[n + j*p_Nq];
              ps += Vs_ij * pj;
              us += Vs_ij * uj;
              vs += Vs_ij * vj;
              ws += Vs_ij * wj;

              const dfloat Vt_ij = Vtq[n + j*p_Nq];
              pt += Vt_ij * pj;
              ut += Vt_ij * uj;
              vt += Vt_ij * vj;
              wt += Vt_ij * wj;
            }

            const dfloat dpdx = pr * rxq + ps * sxq + pt * txq;
            const dfloat dpdy = pr * ryq + ps * syq + pt * tyq;
            const dfloat dpdz = pr * rzq + ps * szq + pt * tzq;
            dfloat divU = ur * rxq + us * sxq + ut * txq;
            divU       += vr * ryq + vs * syq + vt * tyq;
            divU       += wr * rzq + ws * szq + wt * tzq;

            // write out to global mem
            id = n + 6*p_Nq*k;
            Qtmp[id] = divU * Jqn; id += p_Nq;
            Qtmp[id] = dpdx * Jqn; id += p_Nq;
            Qtmp[id] = dpdy * Jqn; id += p_Nq;
            Qtmp[id] = dpdz * Jqn;

            n += p_ceilNq;
          }
	}
      }
    }

  }
}

kernel void rk_volume_WADG_Qtmp(const int K,
				const int * restrict Klist,
				const dfloat * restrict Pq,
				const dfloat * restrict Qtmp,
				dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkV-1)/p_KblkV; ++k1; outer0){

    shared dfloat sp[p_KblkV][p_Nq];
    shared dfloat su[p_KblkV][p_Nq];
    shared dfloat sv[p_KblkV][p_Nq];
    shared dfloat sw[p_KblkV][p_Nq];

    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){

      // loop over nodes
      for(int n=0; n<p_Nq; ++n;inner0){

	kindex = k1*p_KblkV + k2;
	k = Klist[kindex];

	if (kindex < K){

	  // load p into shared memory for element k
	  int id = n + k*p_Nq*6;
	  sp[k2][n] = Qtmp[id]; id += p_Nq;
	  su[k2][n] = Qtmp[id]; id += p_Nq;
	  sv[k2][n] = Qtmp[id]; id += p_Nq;
	  sw[k2][n] = Qtmp[id];

	}
      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      for(int n=0;n<p_Nq;++n;inner0){ // loop over quad nodes

	if (kindex < K && n < p_Np){
	  dfloat divU = 0.f, dpdx = 0.f, dpdy = 0.f, dpdz = 0.f;
	  for(int m = 0; m < p_Nq; ++m){ // ILP
	    const dfloat Pq_m = Pq[n + m*p_Np];

	    divU += Pq_m * sp[k2][m];
	    dpdx += Pq_m * su[k2][m];
	    dpdy += Pq_m * sv[k2][m];
	    dpdz += Pq_m * sw[k2][m];
	  }
	  int id = n + k*p_Np*p_Nfields;
	  rhsQ[id] = -divU; id += p_Np;
	  rhsQ[id] = -dpdx; id += p_Np;
	  rhsQ[id] = -dpdy; id += p_Np;
	  rhsQ[id] = -dpdz;


	} // k < K
      } //inner0
    } // inner1

  }
}

kernel void rk_surface_WADG(const    int K,
			    const    int * restrict Klist,
			    const dfloat * restrict fgeo,
			    const dfloat * restrict fgeoq,
			    const dfloat * restrict VfqFace,
			    const dfloat * restrict Pfq,
			    const    int * restrict Fmask,
			    const    int * restrict vmapP,
			    const dfloat * restrict Q,
			    dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0;k1<(K+p_KblkS-1)/p_KblkS;++k1;outer0){

    shared dfloat s_dp[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_du[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_dv[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_dw[p_KblkS][p_Nfaces][p_Nfp];

    shared dfloat s_pflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_uflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_vflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_wflux[p_KblkS][p_NfqNfaces];

    exclusive int k,kindex;

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n < p_Nfq;++n;inner0){

	kindex = k1*p_KblkS + k2; k = Klist[kindex];
	//kindex = k1*p_KblkS + k2; k = kindex;

	if (kindex < K && n < p_Nfp){

	  for (int f = 0; f < p_Nfaces; ++f){

            int m = n + f*p_Nfp;
	    // move this early - starts vmapP fetch early
	    const int fid = Fmask[m];
            int idM = fid + k*p_Np*p_Nfields;
            int idP = vmapP[m + k*p_NfpNfaces];
	    const int isBoundary = idM==idP;

	    const dfloat pM = Q[idM]; idM += p_Np;
	    const dfloat uM = Q[idM]; idM += p_Np;
	    const dfloat vM = Q[idM]; idM += p_Np;
	    const dfloat wM = Q[idM];

	    const dfloat pP = Q[idP]; idP += p_Np;
	    const dfloat uP = Q[idP]; idP += p_Np;
	    const dfloat vP = Q[idP]; idP += p_Np;
	    const dfloat wP = Q[idP];

	    s_dp[k2][f][n] = (isBoundary) ? -2.f*pM : pP-pM;
	    s_du[k2][f][n] = (isBoundary) ?  0.f    : uP-uM;
	    s_dv[k2][f][n] = (isBoundary) ?  0.f    : vP-vM;
	    s_dw[k2][f][n] = (isBoundary) ?  0.f    : wP-wM;

	  }// faces

	}
      }
    }
    barrier(localMemFence);

    // eval at quad pts
    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_Nfq;++n;inner0){

	if (kindex < K){

	  dfloat dpq[p_Nfaces];
	  dfloat duq[p_Nfaces],dvq[p_Nfaces],dwq[p_Nfaces];
	  for (int f = 0; f < p_Nfaces; ++f){
	    dpq[f] = 0.f;
	    duq[f] = 0.f; dvq[f] = 0.f; dwq[f] = 0.f;
	  }
	  occaUnroll(p_Nfp)
	  for (int j = 0; j < p_Nfp; ++j){
	    const dfloat VfqFace_ij = VfqFace[n + j*p_Nfq];

	    for (int f = 0; f < p_Nfaces; ++f){
	      dpq[f] += VfqFace_ij * s_dp[k2][f][j];
	      duq[f] += VfqFace_ij * s_du[k2][f][j];
	      dvq[f] += VfqFace_ij * s_dv[k2][f][j];
	      dwq[f] += VfqFace_ij * s_dw[k2][f][j];
	    }
	  }

	  for (int f = 0; f < p_Nfaces; ++f){
	    int id = n + f*p_Nfq*p_Nfgeo + k*p_Nfq*p_Nfaces*p_Nfgeo;
	    const dfloat nxq = fgeoq[id];  id += p_Nfq;
	    const dfloat nyq = fgeoq[id];  id += p_Nfq;
	    const dfloat nzq = fgeoq[id];  id += p_Nfq;
	    const dfloat sJq = fgeoq[id];

	    // compute flux at quad pts
	    const int fid = n + f*p_Nfq;
            const dfloat Unjump = duq[f]*nxq + dvq[f]*nyq + dwq[f]*nzq;
	    const dfloat flux = (Unjump - dpq[f])*sJq;
	    s_pflux[k2][fid] = -.5f*flux;
	    s_uflux[k2][fid] =  .5f*flux * nxq;
	    s_vflux[k2][fid] =  .5f*flux * nyq;
	    s_wflux[k2][fid] =  .5f*flux * nzq;

	  }

	}
      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_Nfq;++n;inner0){

	if (kindex < K){
	  int i = n;
	  while (i < p_Np){

	    int id = i + k*p_Np*p_Nfields;
	    dfloat rhsp = rhsQ[id]; id += p_Np;
	    dfloat rhsu = rhsQ[id]; id += p_Np;
	    dfloat rhsv = rhsQ[id]; id += p_Np;
	    dfloat rhsw = rhsQ[id];

	    occaUnroll(p_NfqNfaces)
	    for (int j = 0; j < p_NfqNfaces; ++j){
	      const dfloat Pfq_ij = Pfq[i + j*p_Np];

	      rhsp += Pfq_ij * s_pflux[k2][j];
	      rhsu += Pfq_ij * s_uflux[k2][j];
	      rhsv += Pfq_ij * s_vflux[k2][j];
	      rhsw += Pfq_ij * s_wflux[k2][j];
	    }

	    id = i + k*p_Np*p_Nfields;
	    rhsQ[id] = rhsp; id += p_Np;
	    rhsQ[id] = rhsu; id += p_Np;
	    rhsQ[id] = rhsv; id += p_Np;
	    rhsQ[id] = rhsw;

	    i += p_Nfq;
	  }// n < p_Np

	} // k < K
      } // inner0
    } // k2

  } // outer loop
}


kernel void rk_surface_WADG_face(const    int K,
                                 const    int * restrict Klist,
                                 const dfloat * restrict fgeo,
                                 const dfloat * restrict fgeoq,
                                 const dfloat * restrict VfqFace,
                                 const dfloat * restrict Pfq,
                                 const    int * restrict Fmask,
                                 const    int * restrict vmapP,
                                 const dfloat * restrict Q,
                                 dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0;k1<(K+p_KblkS-1)/p_KblkS;++k1;outer0){

    shared dfloat s_dp[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_du[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_dv[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_dw[p_KblkS][p_Nfaces][p_Nfp];

    shared dfloat s_pflux[p_KblkS][p_Nfq];
    shared dfloat s_uflux[p_KblkS][p_Nfq];
    shared dfloat s_vflux[p_KblkS][p_Nfq];
    shared dfloat s_wflux[p_KblkS][p_Nfq];

    exclusive int k,kindex;
    exclusive dfloat rp,ru,rv,rw;

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0; n < p_Np; ++n;inner0){

	kindex = k1*p_KblkS + k2; k = Klist[kindex];

        if (kindex < K){
          int id = n + k*p_Np*p_Nfields;
          rp = rhsQ[id]; id += p_Np;
          ru = rhsQ[id]; id += p_Np;
          rv = rhsQ[id]; id += p_Np;
          rw = rhsQ[id];
        }

	if (kindex < K && n < p_Nfp){

	  for (int f = 0; f < p_Nfaces; ++f){

            int m = n + f*p_Nfp;
	    // move this early - starts vmapP fetch early
	    const int fid = Fmask[m];
            int idM = fid + k*p_Np*p_Nfields;
            int idP = vmapP[m + k*p_NfpNfaces];
	    const int isBoundary = idM==idP;

	    const dfloat pM = Q[idM]; idM += p_Np;
	    const dfloat uM = Q[idM]; idM += p_Np;
	    const dfloat vM = Q[idM]; idM += p_Np;
	    const dfloat wM = Q[idM];

	    const dfloat pP = Q[idP]; idP += p_Np;
	    const dfloat uP = Q[idP]; idP += p_Np;
	    const dfloat vP = Q[idP]; idP += p_Np;
	    const dfloat wP = Q[idP];

	    s_dp[k2][f][n] = (isBoundary) ? -2.f*pM : pP-pM;
	    s_du[k2][f][n] = (isBoundary) ?  0.f    : uP-uM;
	    s_dv[k2][f][n] = (isBoundary) ?  0.f    : vP-vM;
	    s_dw[k2][f][n] = (isBoundary) ?  0.f    : wP-wM;

	  }// faces

	} // k < K
      } // Np
    } // k2
    barrier(localMemFence);

    // eval at quad pts
    for (int f = 0; f < p_Nfaces; ++f){
      for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
        for(int n=0; n<p_Np; ++n; inner0){

          if (kindex < K && n < p_Nfq){

            dfloat dpq = 0.f, duq = 0.f, dvq = 0.f, dwq = 0.f;
            for (int j = 0; j < p_Nfp; ++j){
              const dfloat VfqFace_ij = VfqFace[n + j*p_Nfq];

	      dpq += VfqFace_ij * s_dp[k2][f][j];
	      duq += VfqFace_ij * s_du[k2][f][j];
	      dvq += VfqFace_ij * s_dv[k2][f][j];
	      dwq += VfqFace_ij * s_dw[k2][f][j];
	    }

	    int id = n + f*p_Nfq*p_Nfgeo + k*p_Nfq*p_Nfaces*p_Nfgeo;
	    const dfloat nxq = fgeoq[id];  id += p_Nfq;
	    const dfloat nyq = fgeoq[id];  id += p_Nfq;
	    const dfloat nzq = fgeoq[id];  id += p_Nfq;
	    const dfloat sJq = fgeoq[id];

	    // compute flux at quad pts
            const dfloat Unjump = duq*nxq + dvq*nyq + dwq*nzq;
	    const dfloat flux = (Unjump - dpq)*sJq;
	    s_pflux[k2][n] = -.5f*flux;
	    s_uflux[k2][n] =  .5f*flux * nxq;
	    s_vflux[k2][n] =  .5f*flux * nyq;
	    s_wflux[k2][n] =  .5f*flux * nzq;

	  }

	}
      }
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
        for(int n=0;n<p_Np;++n;inner0){

          if (kindex < K){

            for (int jj = 0; jj < p_Nfq; ++jj){
              const int j = jj + f*p_Nfq;
              const dfloat Pfq_ij = Pfq[n + j*p_Np];

              rp += Pfq_ij * s_pflux[k2][jj];
              ru += Pfq_ij * s_uflux[k2][jj];
              rv += Pfq_ij * s_vflux[k2][jj];
              rw += Pfq_ij * s_wflux[k2][jj];
            }

          } // k < K
        } // inner0
      }// k2
    }// faces


    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_Np;++n;inner0){

	if (kindex < K){
          int id = n + k*p_Np*p_Nfields;
          rhsQ[id] = rp; id += p_Np;
          rhsQ[id] = ru; id += p_Np;
          rhsQ[id] = rv; id += p_Np;
          rhsQ[id] = rw;

        } // k < K
      } // Nfq
    }// k2
    barrier(localMemFence);

  } // outer loop
}

kernel void rk_surface_WADG_skew_face(const    int K,
                                 const    int * restrict Klist,
                                 const dfloat * restrict fgeo,
                                 const dfloat * restrict fgeoq,
                                 const dfloat * restrict VfqFace,
                                 const dfloat * restrict Pfq,
                                 const    int * restrict Fmask,
                                 const    int * restrict vmapP,
                                 const dfloat * restrict Q,
                                 dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0;k1<(K+p_KblkS-1)/p_KblkS;++k1;outer0){

    shared dfloat s_dp[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_du[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_dv[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_dw[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_au[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_av[p_KblkS][p_Nfaces][p_Nfp];
    shared dfloat s_aw[p_KblkS][p_Nfaces][p_Nfp];

    shared dfloat s_pflux[p_KblkS][p_Nfq];
    shared dfloat s_uflux[p_KblkS][p_Nfq];
    shared dfloat s_vflux[p_KblkS][p_Nfq];
    shared dfloat s_wflux[p_KblkS][p_Nfq];

    exclusive int k,kindex;
    exclusive dfloat rp,ru,rv,rw;

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0; n < p_Np; ++n;inner0){

	kindex = k1*p_KblkS + k2; k = Klist[kindex];

        if (kindex < K){
          int id = n + k*p_Np*p_Nfields;
          rp = rhsQ[id]; id += p_Np;
          ru = rhsQ[id]; id += p_Np;
          rv = rhsQ[id]; id += p_Np;
          rw = rhsQ[id];
        }

	if (kindex < K && n < p_Nfp){

	  for (int f = 0; f < p_Nfaces; ++f){

            int m = n + f*p_Nfp;
	    // move this early - starts vmapP fetch early
	    const int fid = Fmask[m];
            int idM = fid + k*p_Np*p_Nfields;
            int idP = vmapP[m + k*p_NfpNfaces];
	    const int isBoundary = idM==idP;

	    const dfloat pM = Q[idM]; idM += p_Np;
	    const dfloat uM = Q[idM]; idM += p_Np;
	    const dfloat vM = Q[idM]; idM += p_Np;
	    const dfloat wM = Q[idM];

	    const dfloat pP = Q[idP]; idP += p_Np;
	    const dfloat uP = Q[idP]; idP += p_Np;
	    const dfloat vP = Q[idP]; idP += p_Np;
	    const dfloat wP = Q[idP];

	    s_dp[k2][f][n] = (isBoundary) ? -2.f*pM : pP-pM;
	    s_du[k2][f][n] = (isBoundary) ?  0.f    : uP-uM;
	    s_dv[k2][f][n] = (isBoundary) ?  0.f    : vP-vM;
	    s_dw[k2][f][n] = (isBoundary) ?  0.f    : wP-wM;
	    s_au[k2][f][n] = (isBoundary) ?  uM     : .5f*(uP+uM);
	    s_av[k2][f][n] = (isBoundary) ?  uM     : .5f*(vP+vM);
	    s_aw[k2][f][n] = (isBoundary) ?  uM     : .5f*(wP+wM);

	  }// faces

	} // k < K
      } // Np
    } // k2
    barrier(localMemFence);

    // eval at quad pts
    for (int f = 0; f < p_Nfaces; ++f){
      for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
        for(int n=0; n<p_Np; ++n; inner0){

          if (kindex < K && n < p_Nfq){

            dfloat dpq = 0.f, duq = 0.f, dvq = 0.f, dwq = 0.f;
            dfloat auq = 0.f, avq = 0.f, awq = 0.f;
            for (int j = 0; j < p_Nfp; ++j){
              const dfloat VfqFace_ij = VfqFace[n + j*p_Nfq];

	      dpq += VfqFace_ij * s_dp[k2][f][j];
	      duq += VfqFace_ij * s_du[k2][f][j];
	      dvq += VfqFace_ij * s_dv[k2][f][j];
	      dwq += VfqFace_ij * s_dw[k2][f][j];
	      auq += VfqFace_ij * s_au[k2][f][j];
	      avq += VfqFace_ij * s_av[k2][f][j];
	      awq += VfqFace_ij * s_aw[k2][f][j];
	    }

	    int id = n + f*p_Nfq*p_Nfgeo + k*p_Nfq*p_Nfaces*p_Nfgeo;
	    const dfloat nxq = fgeoq[id];  id += p_Nfq;
	    const dfloat nyq = fgeoq[id];  id += p_Nfq;
	    const dfloat nzq = fgeoq[id];  id += p_Nfq;
	    const dfloat sJq = fgeoq[id];

	    // compute flux at quad pts
            const dfloat Unjump = duq*nxq + dvq*nyq + dwq*nzq;
            const dfloat Unavg  = auq*nxq + avq*nyq + awq*nzq;
	    const dfloat pflux = (Unjump - dpq)*sJq;
            const dfloat uflux = (Unavg - .5f*dpq)*sJq;
	    s_pflux[k2][n] = -.5f*pflux;
	    s_uflux[k2][n] =  uflux * nxq;
	    s_vflux[k2][n] =  uflux * nyq;
	    s_wflux[k2][n] =  uflux * nzq;

	  }

	}
      }
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
        for(int n=0;n<p_Np;++n;inner0){

          if (kindex < K){

            for (int jj = 0; jj < p_Nfq; ++jj){
              const int j = jj + f*p_Nfq;
              const dfloat Pfq_ij = Pfq[n + j*p_Np];

              rp += Pfq_ij * s_pflux[k2][jj];
              ru += Pfq_ij * s_uflux[k2][jj];
              rv += Pfq_ij * s_vflux[k2][jj];
              rw += Pfq_ij * s_wflux[k2][jj];
            }

          } // k < K
        } // inner0
      }// k2
    }// faces


    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_Np;++n;inner0){

	if (kindex < K){
          int id = n + k*p_Np*p_Nfields;
          rhsQ[id] = rp; id += p_Np;
          rhsQ[id] = ru; id += p_Np;
          rhsQ[id] = rv; id += p_Np;
          rhsQ[id] = rw;

        } // k < K
      } // Nfq
    }// k2
    barrier(localMemFence);

  } // outer loop
}




kernel void rk_surface_WADG_Qf(const    int K,
			       const    int * restrict Klist,
			       const dfloat * restrict fgeoq,
			       const dfloat * restrict Pfq,
			       const    int * restrict mapPq,
			       const dfloat * restrict Qf,
			       dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0;k1<(K+p_KblkS-1)/p_KblkS;++k1;outer0){

    shared dfloat s_pflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_uflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_vflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_wflux[p_KblkS][p_NfqNfaces];

    exclusive int k,kindex;

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){

      for(int n = 0; n < p_Tq; ++n; inner0){

	kindex = k1*p_KblkS + k2;
	k = Klist[kindex];

	if (kindex < K && n < p_NfqNfaces){

	  // move this early - starts vmapP fetch early
	  int idM = n + p_Nfields * p_NfqNfaces * k;
	  int idP = mapPq[n + p_NfqNfaces * k];
	  const int isBoundary = idM==idP;

	  const dfloat pM = Qf[idM]; idM += p_NfqNfaces;
	  const dfloat uM = Qf[idM]; idM += p_NfqNfaces;
	  const dfloat vM = Qf[idM]; idM += p_NfqNfaces;
	  const dfloat wM = Qf[idM];

	  const dfloat pP = (isBoundary) ? -pM : Qf[idP]; idP += p_NfqNfaces;
	  const dfloat uP = (isBoundary) ?  uM : Qf[idP]; idP += p_NfqNfaces;
	  const dfloat vP = (isBoundary) ?  vM : Qf[idP]; idP += p_NfqNfaces;
	  const dfloat wP = (isBoundary) ?  wM : Qf[idP];

	  int nf = n % p_Nfq;
	  int f = n / p_Nfq;
	  int id = nf + f*p_Nfq*p_Nfgeo + k*p_NfqNfaces*p_Nfgeo;
	  const dfloat nxq = fgeoq[id];  id += p_Nfq;
	  const dfloat nyq = fgeoq[id];  id += p_Nfq;
	  const dfloat nzq = fgeoq[id];  id += p_Nfq;
	  const dfloat sJq = fgeoq[id];

	  // compute flux at quad pts
	  const dfloat pjump = pP - pM;
	  const dfloat Unjump = (uP-uM)*nxq + (vP-vM)*nyq + (wP-wM)*nzq;
	  const dfloat flux = .5f*(Unjump - pjump)*sJq;
	  s_pflux[k2][n] = -flux;
	  s_uflux[k2][n] = flux * nxq;
	  s_vflux[k2][n] = flux * nyq;
	  s_wflux[k2][n] = flux * nzq;


	} // k < K

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0; n<p_Tq; ++n;inner0){

	if (kindex < K && n < p_Np){

	  int id = n + k*p_Np*p_Nfields;
	  dfloat rhsp = rhsQ[id]; id += p_Np;
	  dfloat rhsu = rhsQ[id]; id += p_Np;
	  dfloat rhsv = rhsQ[id]; id += p_Np;
	  dfloat rhsw = rhsQ[id];

	  // testing only
	  //rhsp = 0.f; rhsu = 0.f; rhsv = 0.f; rhsw = 0.f;

	  for (int j = 0; j < p_NfqNfaces; ++j){
	    const dfloat Pfq_ij = Pfq[n + j*p_Np];

	    rhsp += Pfq_ij * s_pflux[k2][j];
	    rhsu += Pfq_ij * s_uflux[k2][j];
	    rhsv += Pfq_ij * s_vflux[k2][j];
	    rhsw += Pfq_ij * s_wflux[k2][j];
	  }

	  //printf("surface rhs = %f, %f, %f, %f\n",rhsp,rhsu,rhsv,rhsw);
	  id = n + k*p_Np*p_Nfields;
	  rhsQ[id] = rhsp; id += p_Np;
	  rhsQ[id] = rhsu; id += p_Np;
	  rhsQ[id] = rhsv; id += p_Np;
	  rhsQ[id] = rhsw;

	} // k < K and n < p_Np
      } // inner0
    } // k2

  } // outer loop
}

kernel void rk_update_WADG(const int K,
			   const dfloat * restrict Vq,
			   const dfloat * restrict Pq,
			   const dfloat * restrict Jq,
			   const dfloat fa,
			   const dfloat fb,
			   const dfloat fdt,
			   const dfloat * restrict rhsQ,
			   dfloat * restrict resQ,
			   dfloat * restrict Q){

  for(int k1=0; k1<(K+p_KblkU-1)/p_KblkU; ++k1; outer0){

    shared dfloat sp[p_KblkV][p_Np];
    shared dfloat su[p_KblkV][p_Np];
    shared dfloat sv[p_KblkV][p_Np];
    shared dfloat sw[p_KblkV][p_Np];

    shared dfloat spq[p_KblkV][p_Np];
    shared dfloat suq[p_KblkV][p_Np];
    shared dfloat svq[p_KblkV][p_Np];
    shared dfloat swq[p_KblkV][p_Np];

    exclusive dfloat rp, ru, rv, rw;
    exclusive dfloat resx, resy, resz, resw;

    exclusive int k;
    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int n = 0; n < p_Np; ++n; inner0){

	k = k1*p_KblkU + k2; // no need for klist here for heterogeneous WADG

	if (k < K){
	  int id = n + k*p_Np*p_Nfields;

	  sp[k2][n] = rhsQ[id]; id += p_Np;
	  su[k2][n] = rhsQ[id]; id += p_Np;
	  sv[k2][n] = rhsQ[id]; id += p_Np;
	  sw[k2][n] = rhsQ[id];
	}

	rp = 0.f; ru = 0.f;
	rv = 0.f; rw = 0.f;
      }
    }
    barrier(localMemFence);

    // loop over Np out of Nq points
    for(int block = 0; block < (p_Nq_reduced + p_Np - 1)/p_Np; ++block){

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int n = 0; n < p_Np; ++n;inner0){

	  // prefetch vars to accumulate
	  if (k < K){
	    int id = n + k*p_Np*p_Nfields;
	    resx = resQ[id]; id += p_Np;
	    resy = resQ[id]; id += p_Np;
	    resz = resQ[id]; id += p_Np;
	    resw = resQ[id];
	  }

	  const int i = n + block*p_Np;

	  if (k < K && i < p_Nq_reduced){

	    // prefetch
	    const dfloat invJ = 1.f / Jq[i + k*p_Nq_reduced];
	    dfloat pq = 0.f;
	    dfloat uq = 0.f, vq = 0.f, wq = 0.f;
	    for (int j = 0; j < p_Np; ++j){

	      const dfloat Vq_ij = Vq[i + j*p_Nq_reduced];
	      pq += Vq_ij * sp[k2][j];
	      uq += Vq_ij * su[k2][j];
	      vq += Vq_ij * sv[k2][j];
	      wq += Vq_ij * sw[k2][j];
	    }

	    // scale by 1/J at quad pts
	    spq[k2][n] = pq * invJ;
	    suq[k2][n] = uq * invJ;
	    svq[k2][n] = vq * invJ;
	    swq[k2][n] = wq * invJ;
	  }
	} // inner0
      } // inner1
      barrier(localMemFence);

      for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
	for(int n = 0; n < p_Np; ++n;inner0){

	  if (k < K){

	    const int Nt = min(p_Np,p_Nq_reduced - block*p_Np);
	    for (int j = 0; j < Nt; ++j){

	      const int jj = j + block*p_Np;
	      const dfloat Pq_ij = Pq[n + jj*p_Np];

	      // accumulate into private vars
	      rp += Pq_ij * spq[k2][j];
	      ru += Pq_ij * suq[k2][j];
	      rv += Pq_ij * svq[k2][j];
	      rw += Pq_ij * swq[k2][j];
	    }
#if 0
	    if (k==0 && block>0){
	      const dfloat rhsp = rp;
	      const dfloat rhsu = ru;
	      const dfloat rhsv = rv;
	      const dfloat rhsw = rw;
	      printf("in update: rhsQ = %f %f %f %f\n",rhsp,rhsu,rhsv,rhsw);
	    }
#endif
	  }

	} // inner0
      }
    } // block loop

    for(int k2 = 0; k2 < p_KblkU; ++k2; inner1){
      for(int n = 0; n < p_Np; ++n;inner0){

	if (k < K){

	  resx = fa*resx + fdt*rp;
	  resy = fa*resy + fdt*ru;
	  resz = fa*resz + fdt*rv;
	  resw = fa*resw + fdt*rw;

#if 0
	  if (k==0){
	    dfloat resp = resx;
	    dfloat resu = resy;
	    dfloat resv = resz;
	    dfloat resw = resw;
	    printf("fa = %f, fdt = %f, resxyzw after updating = %f %f %f %f\n",
		   fa,fdt,resp,resu,resv,resw);
	  }
#endif
	  int id = n + k*p_Np*p_Nfields;
	  resQ[id] = resx; id += p_Np;
	  resQ[id] = resy; id += p_Np;
	  resQ[id] = resz; id += p_Np;
	  resQ[id] = resw;

	  id = n + k * p_Np * p_Nfields;
	  Q[id] += fb*resx; id += p_Np;
	  Q[id] += fb*resy; id += p_Np;
	  Q[id] += fb*resz; id += p_Np;
	  Q[id] += fb*resw;

	}

      } // inner 0
    } // inner1

  }
}

//  =============== RK first order DG kernels ===============

kernel void rk_volume_planar(const    int K,
			     const    int * restrict Klist,
			     const dfloat * restrict vgeo,
			     const dfloat * restrict J,
			     const dfloat * restrict Dr,
			     const dfloat * restrict Ds,
			     const dfloat * restrict Dt,
			     const dfloat * restrict Q,
			     dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkV-1)/p_KblkV; ++k1; outer0){

    // total shared memory amounts to approx. 4 dfloats per thread
    shared dfloat sp[p_KblkV][p_Np];
    shared dfloat sUr[p_KblkV][p_Np], sUs[p_KblkV][p_Np], sUt[p_KblkV][p_Np];
    shared dfloat sG[p_KblkV][p_Nvgeo]; // add in Jacobian scaling - remove later

    exclusive int k, kindex;

    // lapp has to survive multiple inner loops
    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      for(int n=0;n<p_Np;++n;inner0){

	kindex = k1*p_KblkV + k2;  k = Klist[kindex];
	//kindex = k1*p_KblkV + k2;  k = kindex;

	if (kindex < K){

          // load geometric factors into shared memory
          int m = n;
          while(m < p_Nvgeo){
            sG[k2][m] = vgeo[m + p_Nvgeo*k];
            m += p_Np;
          }

        }
      }
    }
    barrier(localMemFence);

#define rx sG[k2][0]
#define ry sG[k2][1]
#define rz sG[k2][2]
#define sx sG[k2][3]
#define sy sG[k2][4]
#define sz sG[k2][5]
#define tx sG[k2][6]
#define ty sG[k2][7]
#define tz sG[k2][8]

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      // loop over nodes
      for(int n=0;n<p_Np;++n;inner0){

	if (kindex < K){

          // load p into shared memory for element k
	  int offset = 0;
	  const int id = n + k*p_Np*p_Nfields;
	  sp[k2][n] = Q[id + offset]; offset += p_Np;
	  const dfloat un = Q[id + offset]; offset += p_Np;
	  const dfloat vn = Q[id + offset]; offset += p_Np;
	  const dfloat wn = Q[id + offset];

          sUr[k2][n] = un*rx + vn*ry + wn*rz;  // should store drdx*u + drdy*v +drdz*w
          sUs[k2][n] = un*sx + vn*sy + wn*sz;  // should store dsdx*u + dsdy*v +dsdz*w
          sUt[k2][n] = un*tx + vn*ty + wn*tz;  // should store dtdx*u + dtdy*v +dtdz*w

	}
      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      // loop over nodes
      for(int n=0;n<p_Np;++n;inner0){

	if (kindex < K){

          dfloat dpdr = 0, dpds = 0, dpdt = 0, divU = 0;
	  for(int m=0;m<p_Np;++m){ // ILP

	    const dfloat Dr_m = Dr[n+m*p_Np];
	    const dfloat Ds_m = Ds[n+m*p_Np];
	    const dfloat Dt_m = Dt[n+m*p_Np];

            const dfloat pm = sp[k2][m];
            dpdr += Dr_m*pm;
            dpds += Ds_m*pm;
            dpdt += Dt_m*pm;
            divU += Dr_m*sUr[k2][m];
            divU += Ds_m*sUs[k2][m];
            divU += Dt_m*sUt[k2][m];
          }

          // GFLOPS: 15 * p_Np
          dfloat dpdx = rx*dpdr + sx*dpds + tx*dpdt;
          dfloat dpdy = ry*dpdr + sy*dpds + ty*dpdt;
          dfloat dpdz = rz*dpdr + sz*dpds + tz*dpdt;

	  const dfloat Jk = J[k];

          int id = n + k*p_Nfields*p_Np;
          rhsQ[id] = -divU * Jk; id += p_Np;
          rhsQ[id] = -dpdx * Jk; id += p_Np;
          rhsQ[id] = -dpdy * Jk; id += p_Np;
          rhsQ[id] = -dpdz * Jk;

        }
      }
    }

  }
}

// split part of kernel
kernel void rk_surface_planar(const    int K,
			      const    int * restrict Klist,
			      const dfloat * restrict fgeo,
			      const dfloat * restrict J,
			      const    int * restrict Fmask,
			      const    int * restrict vmapP,
			      const dfloat * restrict LIFT,
			      const dfloat * restrict Q,
			      dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0;k1<(K+p_KblkS-1)/p_KblkS;++k1;outer0){

    // total shared memory amounts to approx. 4 dfloats per thread
    shared dfloat s_pflux[p_KblkS][p_NfpNfaces];
    shared dfloat s_Uflux[p_KblkS][p_NfpNfaces];

    shared dfloat s_nxyz[p_KblkS][3*p_Nfaces];
    //exclusive int nx, ny, nz;

    shared dfloat s_J[p_KblkS];

    exclusive int k,kindex;

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_T;++n;inner0){

	kindex = k1*p_KblkS + k2;
	k = Klist[kindex];
	if (kindex < K){
	  s_J[k2] = J[k];
	}
      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_T;++n;inner0){

	if (kindex < K){
          // retrieve traces (should move earlier)
          if(n<p_NfpNfaces){

            const int f = n/p_Nfp;

	    const int fid = Fmask[n];
            int idM = fid + k*p_Np*p_Nfields;
            int idP = vmapP[n + k*p_NfpNfaces];
	    const int isBoundary = idM==idP;

            int id = f*p_Nfgeo + p_Nfgeo*p_Nfaces*k;
	    const dfloat Fscale = fgeo[id]*s_J[k2]; // undo J scale
	    const dfloat nx = fgeo[id+1];
	    const dfloat ny = fgeo[id+2];
	    const dfloat nz = fgeo[id+3];
	    int foff = 3*f;
	    s_nxyz[k2][foff] = nx; foff++;
	    s_nxyz[k2][foff] = ny; foff++;
	    s_nxyz[k2][foff] = nz;

	    const dfloat pM = Q[idM]; idM += p_Np;
	    const dfloat uM = Q[idM]; idM += p_Np;
	    const dfloat vM = Q[idM]; idM += p_Np;
	    const dfloat wM = Q[idM];

	    const dfloat pP = Q[idP]; idP += p_Np;
	    const dfloat uP = Q[idP]; idP += p_Np;
	    const dfloat vP = Q[idP]; idP += p_Np;
	    const dfloat wP = Q[idP];

            dfloat pjump = pP-pM;
            dfloat Unjump = (uP-uM)*nx + (vP-vM)*ny + (wP-wM)*nz;
	    if (isBoundary){
	      pjump = -2.f*pM;
	      Unjump = 0.f;
	    }
	    s_pflux[k2][n] = .5f*(pjump - Unjump)*Fscale;
	    s_Uflux[k2][n] = .5f*(Unjump - pjump)*Fscale;

          }
        }
      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0;n<p_T;++n;inner0){

	if (kindex < K){
          if(n<p_Np){

            // accumulate lift/normal lift contributions
	    dfloat val1 = 0.f, val2 = 0.f, val3 = 0.f, val4 = 0.f;

	    //occaUnroll(p_NfpNfaces)
            for(int m=0;m<p_NfpNfaces;++m){
              const dfloat Lnm = LIFT[n+m*p_Np];

              // dv/dn testing
              const int fm = (m/p_Nfp);
              const dfloat dfm = s_Uflux[k2][m];

              // v testing
              val1 += Lnm*s_pflux[k2][m];
              val2 += Lnm*dfm*s_nxyz[k2][3*fm];
              val3 += Lnm*dfm*s_nxyz[k2][1+3*fm];
              val4 += Lnm*dfm*s_nxyz[k2][2+3*fm];
            }

	    int id = n + k*p_Nfields*p_Np;
	    rhsQ[id] += val1; id += p_Np;
	    rhsQ[id] += val2; id += p_Np;
	    rhsQ[id] += val3; id += p_Np;
	    rhsQ[id] += val4;

          }
        }
      }
    }
#endif
  }
}


// =================== skew symmetric form kernels ================

kernel void kernel_write_quad_pts(const int K,
				  const int * restrict Klist,
				  const dfloat * restrict vgeoq,
				  const dfloat * restrict Jq,
				  const dfloat * restrict Vq,
				  const dfloat * restrict Vrq,
				  const dfloat * restrict Vsq,
				  const dfloat * restrict Vtq,
				  const int * restrict Fmask,
				  const dfloat * restrict VfqFace,
				  const dfloat * restrict Vfq,
				  const dfloat * restrict Q,
				  dfloat * restrict Qtmp,
				  dfloat * restrict Qf){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkQ-1)/p_KblkQ; ++k1; outer0){

    shared dfloat sp[p_KblkQ][p_Np];
    shared dfloat su[p_KblkQ][p_Np];
    shared dfloat sv[p_KblkQ][p_Np];
    shared dfloat sw[p_KblkQ][p_Np];
    shared int sFmask[p_NfpNfaces];

    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkQ; ++k2; inner1){

      // loop over nodes
      for(int n=0; n<p_Nq; ++n;inner0){

	kindex = k1*p_KblkQ + k2;
	k = Klist[kindex];

	if (kindex < K && n < p_Np){
	  // load p into shared memory for element k
	  int id = n + k*p_Np*p_Nfields;
	  sp[k2][n] = Q[id]; id += p_Np;
	  su[k2][n] = Q[id]; id += p_Np;
	  sv[k2][n] = Q[id]; id += p_Np;
	  sw[k2][n] = Q[id];
	}

	int m = n;
	while (m < p_NfpNfaces){
	  sFmask[m] = Fmask[m];
	  m += p_Nq;
	}

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkQ; ++k2; inner1){
      for(int n = 0; n<p_Nq; ++n;inner0){

	if (kindex < K){
	  // prefetch
	  int id = n + p_Nq * p_Nvgeo * k;
	  const dfloat rxq = vgeoq[id]; id += p_Nq;
	  const dfloat sxq = vgeoq[id]; id += p_Nq;
	  const dfloat txq = vgeoq[id]; id += p_Nq;
	  const dfloat ryq = vgeoq[id]; id += p_Nq;
	  const dfloat syq = vgeoq[id]; id += p_Nq;
	  const dfloat tyq = vgeoq[id]; id += p_Nq;
	  const dfloat rzq = vgeoq[id]; id += p_Nq;
	  const dfloat szq = vgeoq[id]; id += p_Nq;
	  const dfloat tzq = vgeoq[id];
	  const dfloat Jqn = Jq[n + k*p_Nq];

	  // write out grad p, G^T * u
	  dfloat pr = 0.f, ps = 0.f, pt = 0.f;
	  dfloat uq = 0.f, vq = 0.f, wq = 0.f;
	  for (int j = 0; j < p_Np; ++j){
	    const dfloat Vr_ij = Vrq[n + j*p_Nq];
	    const dfloat Vs_ij = Vsq[n + j*p_Nq];
	    const dfloat Vt_ij = Vtq[n + j*p_Nq];
	    const dfloat pj = sp[k2][j];
	    pr += Vr_ij * pj;
	    ps += Vs_ij * pj;
	    pt += Vt_ij * pj;

	    const dfloat Vq_ij = Vq[n + j*p_Nq];
	    uq += Vq_ij * su[k2][j];
	    vq += Vq_ij * sv[k2][j];
	    wq += Vq_ij * sw[k2][j];
	  }

	  const dfloat dpdx = pr * rxq + ps * sxq + pt * txq;
	  const dfloat dpdy = pr * ryq + ps * syq + pt * tyq;
	  const dfloat dpdz = pr * rzq + ps * szq + pt * tzq;
	  const dfloat Ur = uq * rxq + vq * ryq + wq * rzq;
	  const dfloat Us = uq * sxq + vq * syq + wq * szq;
	  const dfloat Ut = uq * txq + vq * tyq + wq * tzq;

	  // write out to global mem
	  id = n + 6*p_Nq*k;
	  Qtmp[id] = dpdx * Jqn; id += p_Nq;
	  Qtmp[id] = dpdy * Jqn; id += p_Nq;
	  Qtmp[id] = dpdz * Jqn; id += p_Nq;
	  Qtmp[id] =   Ur * Jqn; id += p_Nq;
	  Qtmp[id] =   Us * Jqn; id += p_Nq;
	  Qtmp[id] =   Ut * Jqn;
	  // int kint = k;
	  //printf("Jq(%d,%d) = %f\n",n,kint,Jqn);
	  //printf("Qtmp = %f, %f, %f, %f, %f, %f\n",dpdx,dpdy,dpdz,Ur,Us,Ut);

#if 1
	  if (n < p_Nfq){
	    dfloat pfq[p_Nfaces];	  dfloat ufq[p_Nfaces];
	    dfloat vfq[p_Nfaces];	  dfloat wfq[p_Nfaces];
	    for (int f = 0; f < p_Nfaces; ++f){
	      pfq[f] = 0.f;	    ufq[f] = 0.f;
	      vfq[f] = 0.f;	    wfq[f] = 0.f;
	    }
	    for (int j = 0; j < p_Nfp; ++j){
	      const dfloat Vfq = VfqFace[n + j*p_Nfq];
	      for (int f = 0; f < p_Nfaces; ++f){
		const int fid = sFmask[j + f*p_Nfp];
		pfq[f] += Vfq * sp[k2][fid];
		ufq[f] += Vfq * su[k2][fid];
		vfq[f] += Vfq * sv[k2][fid];
		wfq[f] += Vfq * sw[k2][fid];
	      }
	    }

	    // write out to global memory
	    for (int f = 0; f < p_Nfaces; ++f){
	      int fid = n + f*p_Nfq + p_Nfields * p_NfqNfaces * k;
	      Qf[fid] = pfq[f]; fid += p_NfqNfaces;
	      Qf[fid] = ufq[f]; fid += p_NfqNfaces;
	      Qf[fid] = vfq[f]; fid += p_NfqNfaces;
	      Qf[fid] = wfq[f];
	    }
	  }
#else
	  int m = n;
	  while (m < p_NfqNfaces){
	    dfloat pf = 0.f, uf = 0.f, vf = 0.f, wf = 0.f;
	    for (int j = 0; j < p_Np; ++j){
	      const dfloat Vfq_ij = Vfq[m + j*p_NfqNfaces];
	      pf += Vfq_ij * sp[k2][j];
	      uf += Vfq_ij * su[k2][j];
	      vf += Vfq_ij * sv[k2][j];
	      wf += Vfq_ij * sw[k2][j];
	    }
	    int fid = m + p_Nfields * p_NfqNfaces * k;
	    Qf[fid] = pf; fid += p_NfqNfaces;
	    Qf[fid] = uf; fid += p_NfqNfaces;
	    Qf[fid] = vf; fid += p_NfqNfaces;
	    Qf[fid] = wf;

	    m += p_Nq;
	  }

#endif

	}
      }
    }

  }
}

kernel void kernel_write_vol_quad6(const int K,
                                   const int * restrict Klist,
                                   const dfloat * restrict vgeoq,
                                   const dfloat * restrict Jq,
                                   const dfloat * restrict Vq,
                                   const dfloat * restrict Vrq,
                                   const dfloat * restrict Vsq,
                                   const dfloat * restrict Vtq,
                                   const dfloat * restrict Q,
                                   dfloat * restrict Qtmp){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkQ-1)/p_KblkQ; ++k1; outer0){

    shared dfloat sp[p_KblkQ][p_Np];
    shared dfloat su[p_KblkQ][p_Np];
    shared dfloat sv[p_KblkQ][p_Np];
    shared dfloat sw[p_KblkQ][p_Np];

    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkQ; ++k2; inner1){

      // loop over nodes
      for(int nt=0; nt<p_ceilNq; ++nt;inner0){

	kindex = k1*p_KblkQ + k2;
	k = Klist[kindex];

	if (kindex < K && nt < p_Np){
	  // load p into shared memory for element k
	  int id = nt + k*p_Np*p_Nfields;
	  sp[k2][nt] = Q[id]; id += p_Np;
	  su[k2][nt] = Q[id]; id += p_Np;
	  sv[k2][nt] = Q[id]; id += p_Np;
	  sw[k2][nt] = Q[id];
	}

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkQ; ++k2; inner1){
      for(int nt = 0; nt<p_ceilNq; ++nt;inner0){

	if (kindex < K){
          int n = nt;
          while (n < p_Nq){
	  // prefetch
	  int id = n + p_Nq * p_Nvgeo * k;
	  const dfloat rxq = vgeoq[id]; id += p_Nq;
	  const dfloat sxq = vgeoq[id]; id += p_Nq;
	  const dfloat txq = vgeoq[id]; id += p_Nq;
	  const dfloat ryq = vgeoq[id]; id += p_Nq;
	  const dfloat syq = vgeoq[id]; id += p_Nq;
	  const dfloat tyq = vgeoq[id]; id += p_Nq;
	  const dfloat rzq = vgeoq[id]; id += p_Nq;
	  const dfloat szq = vgeoq[id]; id += p_Nq;
	  const dfloat tzq = vgeoq[id];
	  const dfloat Jqn = Jq[n + k*p_Nq];

	  // write out grad p, G^T * u
	  dfloat pr = 0.f, ps = 0.f, pt = 0.f;
	  dfloat uq = 0.f, vq = 0.f, wq = 0.f;
	  for (int j = 0; j < p_Np; ++j){
	    const dfloat Vr_ij = Vrq[n + j*p_Nq];
	    const dfloat Vs_ij = Vsq[n + j*p_Nq];
	    const dfloat Vt_ij = Vtq[n + j*p_Nq];
	    const dfloat pj = sp[k2][j];
	    pr += Vr_ij * pj;
	    ps += Vs_ij * pj;
	    pt += Vt_ij * pj;

	    const dfloat Vq_ij = Vq[n + j*p_Nq];
	    uq += Vq_ij * su[k2][j];
	    vq += Vq_ij * sv[k2][j];
	    wq += Vq_ij * sw[k2][j];
	  }

	  const dfloat dpdx = pr * rxq + ps * sxq + pt * txq;
	  const dfloat dpdy = pr * ryq + ps * syq + pt * tyq;
	  const dfloat dpdz = pr * rzq + ps * szq + pt * tzq;
	  const dfloat Ur = uq * rxq + vq * ryq + wq * rzq;
	  const dfloat Us = uq * sxq + vq * syq + wq * szq;
	  const dfloat Ut = uq * txq + vq * tyq + wq * tzq;

	  // write out to global mem
	  id = n + 6*p_Nq*k;
	  Qtmp[id] = dpdx * Jqn; id += p_Nq;
	  Qtmp[id] = dpdy * Jqn; id += p_Nq;
	  Qtmp[id] = dpdz * Jqn; id += p_Nq;
	  Qtmp[id] =   Ur * Jqn; id += p_Nq;
	  Qtmp[id] =   Us * Jqn; id += p_Nq;
	  Qtmp[id] =   Ut * Jqn;
          n += p_ceilNq;
          }
	}
      }
    }

  }
}



kernel void kernel_write_surf_quad(const int K,
				   const int * restrict Klist,
				   const int * restrict Fmask,
				   const dfloat * restrict VfqFace,
				   const dfloat * restrict Vfq,
				   const dfloat * restrict Q,
				   dfloat * restrict Qf){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkQf-1)/p_KblkQf; ++k1; outer0){

    shared dfloat sp[p_KblkQf][p_Np];
    shared dfloat su[p_KblkQf][p_Np];
    shared dfloat sv[p_KblkQf][p_Np];
    shared dfloat sw[p_KblkQf][p_Np];
    shared int sFmask[p_NfpNfaces];

    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkQf; ++k2; inner1){

      // loop over nodes
      for(int n=0; n<p_Nfq; ++n;inner0){

	kindex = k1*p_KblkQf + k2;
	k = Klist[kindex];

        int m = n;
	while (kindex < K && m < p_Np){
	  // load p into shared memory for element k
	  int id = m + k*p_Np*p_Nfields;
	  sp[k2][m] = Q[id]; id += p_Np;
	  su[k2][m] = Q[id]; id += p_Np;
	  sv[k2][m] = Q[id]; id += p_Np;
	  sw[k2][m] = Q[id];
          m += p_Nfq;
	}

	m = n;
	while (m < p_NfpNfaces){
	  sFmask[m] = Fmask[m];
	  m += p_Nfq;
	}

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkQf; ++k2; inner1){
      for(int n = 0; n<p_Nfq; ++n;inner0){

	if (kindex < K){

#if 1
          dfloat pfq[p_Nfaces];	  dfloat ufq[p_Nfaces];
          dfloat vfq[p_Nfaces];	  dfloat wfq[p_Nfaces];
          for (int f = 0; f < p_Nfaces; ++f){
            pfq[f] = 0.f;	    ufq[f] = 0.f;
            vfq[f] = 0.f;	    wfq[f] = 0.f;
          }
          for (int j = 0; j < p_Nfp; ++j){
            const dfloat Vfq = VfqFace[n + j*p_Nfq];
            for (int f = 0; f < p_Nfaces; ++f){
              const int fid = sFmask[j + f*p_Nfp];
              pfq[f] += Vfq * sp[k2][fid];
              ufq[f] += Vfq * su[k2][fid];
              vfq[f] += Vfq * sv[k2][fid];
              wfq[f] += Vfq * sw[k2][fid];
            }
          }

          // write out to global memory
          for (int f = 0; f < p_Nfaces; ++f){
            int fid = n + f*p_Nfq + p_Nfields * p_NfqNfaces * k;
            Qf[fid] = pfq[f]; fid += p_NfqNfaces;
            Qf[fid] = ufq[f]; fid += p_NfqNfaces;
            Qf[fid] = vfq[f]; fid += p_NfqNfaces;
            Qf[fid] = wfq[f];
          }
#else
	  int m = n;
	  while (m < p_NfqNfaces){
	    dfloat pf = 0.f, uf = 0.f, vf = 0.f, wf = 0.f;
	    for (int j = 0; j < p_Np; ++j){
	      const dfloat Vfq_ij = Vfq[m + j*p_NfqNfaces];
	      pf += Vfq_ij * sp[k2][j];
	      uf += Vfq_ij * su[k2][j];
	      vf += Vfq_ij * sv[k2][j];
	      wf += Vfq_ij * sw[k2][j];
	    }
	    int fid = m + p_Nfields * p_NfqNfaces * k;
	    Qf[fid] = pf; fid += p_NfqNfaces;
	    Qf[fid] = uf; fid += p_NfqNfaces;
	    Qf[fid] = vf; fid += p_NfqNfaces;
	    Qf[fid] = wf;

	    m += p_Nq;
	  }

#endif

	}
      }
    }

  }
}



kernel void rk_volume_WADG_skew(const int K,
				const int * restrict Klist,
				const dfloat * restrict Pq,
				const dfloat * restrict Prq,
				const dfloat * restrict Psq,
				const dfloat * restrict Ptq,
				const dfloat * restrict Qtmp,
				dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0; k1<(K+p_KblkV-1)/p_KblkV; ++k1; outer0){

    shared dfloat sdpdx[p_KblkV][p_Nq];
    shared dfloat sdpdy[p_KblkV][p_Nq];
    shared dfloat sdpdz[p_KblkV][p_Nq];
    shared dfloat su[p_KblkV][p_Nq];
    shared dfloat sv[p_KblkV][p_Nq];
    shared dfloat sw[p_KblkV][p_Nq];

    exclusive int k, kindex;

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){

      // loop over nodes
      for(int n=0; n<p_Np; ++n;inner0){

	kindex = k1*p_KblkV + k2;
	k = Klist[kindex];

	if (kindex < K){

	  // load p into shared memory for element k
	  int m = n;
	  while (m < p_Nq){
	    int id = m + k*p_Nq*6;
	    sdpdx[k2][m] = Qtmp[id]; id += p_Nq;
	    sdpdy[k2][m] = Qtmp[id]; id += p_Nq;
	    sdpdz[k2][m] = Qtmp[id]; id += p_Nq;
	    su[k2][m]    = Qtmp[id]; id += p_Nq;
	    sv[k2][m]    = Qtmp[id]; id += p_Nq;
	    sw[k2][m]    = Qtmp[id];

#if 0
	    if (k==0){
	      dfloat dpdx = sdpdx[k2][m];
	      dfloat dpdy = sdpdy[k2][m];
	      dfloat dpdz = sdpdz[k2][m];
	      dfloat Ur = su[k2][m];
	      dfloat Us = sv[k2][m];
	      dfloat Ut = sw[k2][m];
	      printf("Qtmp[%d] = %f, %f, %f, %f, %f, %f\n",m,dpdx,dpdy,dpdz,Ur,Us,Ut);
	    }
#endif
	    m += p_Np;
	  }
	}

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkV; ++k2; inner1){
      for(int n=0;n<p_Np;++n;inner0){ // loop over quad nodes

	if (kindex < K){

	  dfloat dpdx = 0.f, dpdy = 0.f, dpdz = 0.f, divU = 0.f;
	  for(int j = 0; j < p_Nq; ++j){ // ILP
	    const dfloat Pq_ij = Pq[n + j*p_Np];
	    dpdx += Pq_ij * sdpdx[k2][j];
	    dpdy += Pq_ij * sdpdy[k2][j];
	    dpdz += Pq_ij * sdpdz[k2][j];

	    const dfloat Prq_ij = Prq[n + j*p_Np];
	    divU += Prq_ij * su[k2][j];
	    const dfloat Psq_ij = Psq[n + j*p_Np];
	    divU += Psq_ij * sv[k2][j];
	    const dfloat Ptq_ij = Ptq[n + j*p_Np];
	    divU += Ptq_ij * sw[k2][j];

	  }
	  //	  if (k==0){
	  //	    printf("rhsQ[%d] = %f, %f, %f, %f\n",n,divU,-dpdx,-dpdy,-dpdz);
	  //	  }
	  int id = n + k*p_Np*p_Nfields;
	  rhsQ[id] = divU; id += p_Np;
	  rhsQ[id] = -dpdx; id += p_Np;
	  rhsQ[id] = -dpdy; id += p_Np;
	  rhsQ[id] = -dpdz;

	} // k < K
      } //inner0
    } // inner1
  } // outer

}

kernel void rk_surface_WADG_skew(const    int K,
				 const    int * restrict Klist,
				 const dfloat * restrict fgeoq,
				 const dfloat * restrict Pfq,
				 const    int * restrict mapPq,
				 const dfloat * restrict Qf,
				 dfloat * restrict rhsQ){

  // loop over elements
  for(int k1=0;k1<(K+p_KblkS-1)/p_KblkS;++k1;outer0){

    shared dfloat s_pflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_uflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_vflux[p_KblkS][p_NfqNfaces];
    shared dfloat s_wflux[p_KblkS][p_NfqNfaces];

    exclusive int k,kindex;

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){

      for(int n = 0; n < p_Tq; ++n; inner0){

	kindex = k1*p_KblkS + k2;
	k = Klist[kindex];

	if (kindex < K && n < p_NfqNfaces){

	  // move this early - starts vmapP fetch early
	  int idM = n + p_Nfields * p_NfqNfaces * k;
	  int idP = mapPq[n + p_NfqNfaces * k];
	  const int isBoundary = idM==idP;

	  const dfloat pM = Qf[idM]; idM += p_NfqNfaces;
	  const dfloat uM = Qf[idM]; idM += p_NfqNfaces;
	  const dfloat vM = Qf[idM]; idM += p_NfqNfaces;
	  const dfloat wM = Qf[idM];

	  const dfloat pP = (isBoundary) ? -pM : Qf[idP]; idP += p_NfqNfaces;
	  const dfloat uP = (isBoundary) ?  uM : Qf[idP]; idP += p_NfqNfaces;
	  const dfloat vP = (isBoundary) ?  vM : Qf[idP]; idP += p_NfqNfaces;
	  const dfloat wP = (isBoundary) ?  wM : Qf[idP];

	  int nf = n % p_Nfq;
	  int f = n / p_Nfq;
	  int id = nf + f*p_Nfq*p_Nfgeo + k*p_NfqNfaces*p_Nfgeo;
	  //int id = n + k * p_NfqNfaces * p_Nfgeo;
	  const dfloat nxq = fgeoq[id];  id += p_Nfq;
	  const dfloat nyq = fgeoq[id];  id += p_Nfq;
	  const dfloat nzq = fgeoq[id];  id += p_Nfq;
	  const dfloat sJq = fgeoq[id];

	  // compute flux at quad pts
	  const dfloat pjump = pP - pM;
	  const dfloat Unjump = (uP-uM)*nxq + (vP-vM)*nyq + (wP-wM)*nzq;
	  const dfloat Unavg  = .5f*((uP+uM)*nxq + (vP+vM)*nyq + (wP+wM)*nzq);
	  const dfloat pflux = (.5f*pjump - Unavg)*sJq;
	  const dfloat uflux = .5f*(Unjump - pjump)*sJq;
	  s_pflux[k2][n] = pflux;
	  s_uflux[k2][n] = uflux * nxq;
	  s_vflux[k2][n] = uflux * nyq;
	  s_wflux[k2][n] = uflux * nzq;
	  //	  if (kindex==0){
          //	    printf("pjump = %f, uavg = %f, ujump = %f\n",pjump,Unavg,Unjump);
          //	    printf("n = %d, nxyzq = %f, %f, %f, sJq = %f, pflux,uflux = %f, %f\n",
          //		   n,nxq,nyq,nzq,sJq,pflux,uflux);
          //printf("isBoundary = %d, QM = %f, %f, %f, %f, QP = %f, %f, %f, %f\n",
          //isBoundary,pM,uM,vM,wM,pP,uP,vP,wP);
	  //	  }

	} // k < K

      }
    }
    barrier(localMemFence);

    for(int k2 = 0; k2 < p_KblkS; ++k2; inner1){
      for(int n=0; n<p_Tq; ++n;inner0){

	if (kindex < K && n < p_Np){

	  int id = n + k*p_Np*p_Nfields;
	  dfloat rhsp = rhsQ[id]; id += p_Np;
	  dfloat rhsu = rhsQ[id]; id += p_Np;
	  dfloat rhsv = rhsQ[id]; id += p_Np;
	  dfloat rhsw = rhsQ[id];

	  // testing only
	  //rhsp = 0.f; rhsu = 0.f; rhsv = 0.f; rhsw = 0.f;

	  for (int j = 0; j < p_NfqNfaces; ++j){
	    const dfloat Pfq_ij = Pfq[n + j*p_Np];

	    rhsp += Pfq_ij * s_pflux[k2][j];
	    rhsu += Pfq_ij * s_uflux[k2][j];
	    rhsv += Pfq_ij * s_vflux[k2][j];
	    rhsw += Pfq_ij * s_wflux[k2][j];
	  }

	  //printf("surface rhs = %f, %f, %f, %f\n",rhsp,rhsu,rhsv,rhsw);
	  id = n + k*p_Np*p_Nfields;
	  rhsQ[id] = rhsp; id += p_Np;
	  rhsQ[id] = rhsu; id += p_Np;
	  rhsQ[id] = rhsv; id += p_Np;
	  rhsQ[id] = rhsw;

	} // k < K and n < p_Np
      } // inner0
    } // k2

  } // outer loop
}
