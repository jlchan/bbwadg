\pdfoutput=1

%\documentclass[preprint,10pt]{elsarticle}
\documentclass[preprint,10pt]{article}
%\documentclass[review]{siamart0216}
%\documentclass{siamart0216}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}
\newtheorem*{remark}{Remark}
%\usepackage{thmtools}
%\declaretheorem[style=definition,qed=$\blacksquare$,numberwithin=chapter]{definition}

\usepackage[titletoc,toc,title]{appendix}

\usepackage{array} 
\usepackage{listings}
\usepackage{mathtools}
\usepackage{pdfpages}
\usepackage[textsize=footnotesize,color=green]{todonotes}
\usepackage{bm}
\usepackage{bbm}

%\usepackage{tikz}
\usepackage[normalem]{ulem}
\usepackage{hhline}

%% ====================================== alg package
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{algorithmicx}
\algblock{ParFor}{EndParFor}
% customising the new block
\algnewcommand\algorithmicparfor{\textbf{parfor}}
\algnewcommand\algorithmicpardo{\textbf{do}}
\algnewcommand\algorithmicendparfor{\textbf{end\ parfor}}
\algrenewtext{ParFor}[1]{\algorithmicparfor\ #1\ \algorithmicpardo}
\algrenewtext{EndParFor}{\algorithmicendparfor}
%% ====================================== end alg package

\usepackage{graphicx}
\usepackage{subfig}
\usepackage{color}

%% ====================================== graphics

\usepackage{pgfplots}
\usepackage{pgfplotstable}
\definecolor{markercolor}{RGB}{124.9, 255, 160.65}
\pgfplotsset{width=10cm,compat=1.3}
\pgfplotsset{
tick label style={font=\small},
label style={font=\small},
legend style={font=\small}
}

\usetikzlibrary{calc}

%%% START MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.
\newcommand{\logLogSlopeTriangle}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        \pgfmathsetmacro{\xArel}{#1}
        \pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{\yArel}
        \pgfmathsetmacro{\xCrel}{\xArel}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=0.5,anchor=north] {1}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=west] {#4}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.

\newcommand{\logLogSlopeTriangleNeg}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        \pgfmathsetmacro{\xArel}{#1}
        \pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{\yArel}
        \pgfmathsetmacro{\xCrel}{\xArel}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=.5,anchor=south] {1}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=west] {#4}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.

%%% START MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.
\newcommand{\logLogSlopeTriangleFlipNeg}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        %\pgfmathsetmacro{\xArel}{#1}
        %\pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{#3}
        \pgfmathsetmacro{\xCrel}{#1}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

	\pgfmathsetmacro{\xArel}{\xBrel}
        \pgfmathsetmacro{\yArel}{\yCrel}

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=0.5,anchor=east] {#4}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=north] {1}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.


%%% START MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.
\newcommand{\logLogSlopeTriangleFlip}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        %\pgfmathsetmacro{\xArel}{#1}
        %\pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{#3}
        \pgfmathsetmacro{\xCrel}{#1}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

	\pgfmathsetmacro{\xArel}{\xBrel}
        \pgfmathsetmacro{\yArel}{\yCrel}

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=0.5,anchor=east] {#4}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=south] {1}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.



\usepackage{stmaryrd}


\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}

\newcommand{\vect}[1]{\ensuremath\boldsymbol{#1}}
\newcommand{\tensor}[1]{\underline{\bm{#1}}}
\newcommand{\del}{\triangle}
\newcommand{\curl}{\grad \times}
\renewcommand{\div}{\grad \cdot}

\newcommand{\bbm}[1]{\mathbbm{#1}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\equaldef}{\stackrel{\mathrm{def}}{=}}

\newcommand{\td}[2]{\frac{{\rm d}#1}{{\rm d}{\rm #2}}}
\newcommand{\pd}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\pdd}[2]{\frac{\partial^2#1}{\partial#2^2}}
\newcommand{\pdn}[3]{\frac{\partial^{#3}#1}{\partial#2^{#3}}}
\newcommand{\mb}[1]{\mathbf{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\snor}[1]{\left| #1 \right|}
\newcommand{\nor}[1]{\left\| #1 \right\|}
\newcommand{\LRp}[1]{\left( #1 \right)}
\newcommand{\LRs}[1]{\left[ #1 \right]}
\newcommand{\LRa}[1]{\left\langle #1 \right\rangle}
\newcommand{\LRb}[1]{\left| #1 \right|}
\newcommand{\LRc}[1]{\left\{ #1 \right\}}
\newcommand{\LRceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\LRl}[1]{\left. #1 \right|}

%\newcommand{\cond}[1]{\kappa\LRp{#1}}
\newcommand{\cond}[2]{\nor{#1}_{#2}\nor{{#1}^{-1}}_{#2}}


\newcommand{\Grad} {\ensuremath{\nabla}}
\newcommand{\Div} {\ensuremath{\nabla\cdot}}
\newcommand{\jump}[1] {\ensuremath{\llbracket#1\rrbracket}}
\newcommand{\avg}[1] {\ensuremath{\LRc{\!\{#1\}\!}}}

\newcommand{\Oh}{{\Omega_h}}
\renewcommand{\L}{L^2\LRp{\Omega}}
\newcommand{\LK}{L^2\LRp{D^k}}
\newcommand{\LdK}{L^2\LRp{\partial D^k}}
\newcommand{\Dhat}{\widehat{D}}
\newcommand{\Lhat}{L^2\LRp{\Dhat}}

\newcommand{\eval}[2][\right]{\relax
  \ifx#1\right\relax \left.\fi#2#1\rvert}

\def\etal{{\it et al.~}}


\newcommand{\note}[1]{{\color{blue}{#1}}}


\newcommand{\LinfDk}{L^{\infty}\LRp{D^k}}

\newcommand{\diag}[1]{{\rm diag}\LRp{#1}}

\newcommand{\Ksub}{K_{\rm sub}}

\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

%% d in integrand
\newcommand*\diff[1]{\mathop{}\!{\mathrm{d}#1}}


\makeatletter
\renewcommand\d[1]{\mspace{6mu}\mathrm{d}#1\@ifnextchar\d{\mspace{-3mu}}{}}
\makeatother

\date{}
\author{Jesse Chan}
\title{Energy stable discontinuous Galerkin formulations using discrete differential operators}

\begin{document}

\maketitle

\begin{abstract}
We show that, for non-linear hyperbolic conservation laws which admit a skew-symmetric splitting, energy stable discontinuous Galerkin (DG) methods can be constructed in a straightforward manner based on discrete DG gradient and divergence operators.  In particular, we show that these formulations remain energy stable for both curvilinear geometries and inexact quadrature.  Examples of energy stable formulations are given for variable advection, Burgers' equation, and a Burgers'-like system, and it is shown that the construction of DG methods based on discrete differential operators recover known entropy-conservative fluxes.  
\end{abstract}

\section{Introduction}

Non-conservative discretizations \cite{rhebergen2008discontinuous}.  

DG calculus \cite{feng2016discontinuous} usually assumes exact integration.  As pointed out in \cite{gassner2016split}, this can be either be very expensive (curvilinear meshes or polynomial nonlinearities) or impossible (in the presence of rational integrands, such as for compressible flow).  

Lifting operators and discrete gradients \cite{bassi1997high, di2011mathematical}.  

Goal: reduce aliasing in advective problems caused by variable coefficients and curvilinear or non-affine mappings.  Resembles ideas from summation by parts \cite{olsson1995summation1, olsson1995summation2, hicken2016multidimensional}, but based on global DG differentiation operators. 



\section{Discrete differential operators}

We assume that the domain $\Omega$ is decomposed into non-overlapping elements $D^k$.  We define the mesh $\Omega_h = \cup D^k$ and the corresponding global approximation space $V_h(\Omega_h) = \bigoplus V_h\LRp{D^k}$, where $V_h\LRp{D^k}$ is the approximation space over a single patch.  Furthermore, we introduce the jump and average of discontinuous functions across element interfaces.  Let $D^{k,+}$ denote the neighboring element of across a face $f$ of $D^k$, and let $u^+,u^-$ denote the values of $u$ on $D^{k,+}$ and $D^k$, respectively.  The jump of $u$ across $f$ is then defined as
\[
\jump{u} = u^+ - u^-, \qquad \avg{u} = \frac{u^+ + u^-}{2}.
\]
On faces which coincide with the boundary $\partial \Omega$, the average and jump are defined as
\[
\jump{u} = 0, \qquad \avg{u} = u.
\]
The jump and average of vector fields are defined component-wise using the jumps and averages of components.  

We will assume for now that all elements are affine mappings of a reference element $\widehat{D}$.  Extensions to curvilinear meshes and non-affine mappings will be discussed in Section~\ref{sec:curv}.  

\subsection{Discrete inner products}

In order to define discrete differential operators, we first introduce the $L^2$ inner product on $V_h\LRp{\Oh}$
\[
\LRp{u,v}_{\Omega} = \sum_{k} \int_{D^k} uv \diff{x} = \sum_{k} \int_{\widehat{D}} uv J \diff{\widehat{x}},
\]
and the associated $L^2$ projection $\Pi_N: L^2\LRp{\Omega}\rightarrow P^N$
\[
\LRp{\Pi_N u,v}_{\Omega} = \LRp{u,v}_{\Omega}.  
\]

In practice, these integrals are computed using quadrature, such that 
\begin{equation}
\int_{\widehat{D}}uv = \sum_{i=1}^{N_q} u(\bm{x}_i)v(\bm{x}_i) w_i,
\label{eq:quad}
\end{equation}
where $N_q$ is the number of quadrature points.  The only assumptions we make upon this quadrature is that it is sufficiently accurate such that 
\begin{enumerate}
\item The quadrature induces an $L^2$-equivalent inner product over the reference element $\widehat{D}$.
\item The quadrature is sufficiently accurate such that integration by parts holds with respect to the reference coordinates $\widehat{x}$.
\end{enumerate}


\subsection{Discrete derivatives}
We introduce two discrete DG derivatives in this section, based on definitions used in \cite{di2011mathematical} and \cite{hesthaven2004high,Warburton20063205}:
\begin{definition}
We define two discontinuous Galerkin differentiation operators ${D}^i: L^2\LRp{\Omega}\rightarrow V_h$ and $\tilde{D}^i: L^2\LRp{\Omega}\rightarrow V_h$ is defined implicitly as follows:
\begin{align}
\LRp{{D}^i u,v}_{\Oh} &= \sum_{k} \LRp{\LRp{-u,\pd{v}{\bm{x}_i}}_{\LK} + \LRa{\avg{u},v\bm{n}_i}_{\LdK}}, \qquad \forall v \in V_h\\
\LRp{\tilde{D}^i u,v}_{\Oh} &= \sum_{k} \LRp{\LRp{\pd{u}{\bm{x}_i},v}_{\LK} - \frac{1}{2}\LRa{\jump{u},v\bm{n}_i}_{\LdK}}, \qquad \forall v\in V_h.
\label{eq:dgd1}
\end{align}
\end{definition}

We note that, assuming $u,v \in V_h$ and sufficiently accurate quadrature, $D^i$ and $\tilde{D}^i$ are equivalent.  The main property of the discrete derivatives utilized in this work is a discrete integration-by-parts formula.  
\begin{lemma}
Let $u,v\in V_h$.  Then, 
\begin{align*}
\LRp{D^i u,v} &= \LRp{-u,D^i_h v} + \int_{\partial \Omega} uv \bm{n}_i.
%\LRp{D_h^i u,v} &= \LRp{-u,D^i_h v} + \int_{\partial \Omega} uv \bm{n}_i.
\end{align*}
\label{lemma:ibp}
\end{lemma}
\begin{proof}
Assuming that quadrature is sufficiently accurate for $u, v\in V_h$, integration by parts gives the equivalence. 
\end{proof}

For $u \not\in V_h$, due to the fact that the quadrature rule (\ref{eq:quad}) may not be exact, and these two definitions are not equivalent and Lemma~\ref{lemma:ibp} does not hold.  This motivates the definition of a \textit{discrete} DG differentiation operator:
\begin{definition}
The discrete discontinuous Galerkin differentiation operator ${D}^i_h: L^2\LRp{\Omega} \rightarrow V_h$ is defined as $D^i_h = D^i \Pi_N$.
\end{definition}

Using these discrete derivatives, we can define discrete gradient and divergence operators
\begin{definition}
Let $u \in V_h$ and $\bm{u}\in \LRp{V_h}^d$.  Then, discrete gradient and divergence operators are defined as
\begin{align*}
\LRp{\Grad^{\rm DG} u}_i &= D^i u, \qquad \Grad^{\rm DG}\cdot \bm{u} = \sum_{i=1}^d D^i \bm{u}_i\\
\LRp{\Grad^{\rm DG}_h u}_i &= D_h^i u, \qquad \Grad^{\rm DG}_h\cdot \bm{u} = \sum_{i=1}^d D_h^i \bm{u}_i.
\end{align*}
\end{definition} 

When the support of $v$ is limited to a single element, we have
\[
\LRp{\Grad_h\cdot \bm{u},v\bbm{1}_{D^k}} = \LRp{\bm{u}, \Grad\cdot v\bbm{1}_{D^k}}  + \LRa{\avg{\bm{u}}\cdot\bm{n},v}_{\partial D^k}.
\]
and as a result when $v = 1$
\[
\LRp{\Grad_h\cdot \bm{u},\bbm{1}_{D^k}} = \int_{\partial D^k}\avg{\bm{u}}\cdot\bm{n}
\]

\section{Examples}

\begin{itemize}
\item Tensor product elements: inner product computed using GLL nodes, $\Pi_N$ reduces to nodal interpolation
\item General elements: $\Pi_N$ is just quadrature-based projection.  For accuracy, degree $2N$ or higher?  
\item Triangles and tetrahedra: lumped quadrature nodes.  Implies that mass lumping on triangles requires sufficiently accurate quadrature such that IBP holds.  This conclusion was first reached in the study of multi-dimensional SBP operators \cite{hicken2016multidimensional}.  
\item General elements: $\Pi_N$ can be taken to be nodal interpolation.  
\item Pyramids: need to account for non-affine mappings.  
\end{itemize}

\subsection{Variable advection}

A split formulation for advection is 
\[
\LRp{\pd{u}{t},v} + \frac{1}{2}\LRp{\Grad_h\cdot \Pi_N \LRp{ \bm{\beta}u},v} + \frac{1}{2}\LRp{\bm{\beta}\cdot\Grad_h u,v} + \frac{1}{2}\LRp{\LRp{\Grad\cdot \bm{\beta}} u,v} = 0.
\]
Taking $v = u$ yields and using $\LRp{\Grad_h u, \bm{v}} = \LRp{-u, \Grad_h \cdot \bm{v}}$ yields the energy statement
\[
\frac{1}{2}\nor{u}^2 + \frac{1}{2}\LRp{\Grad_h\cdot \Pi_N \LRp{ \bm{\beta}u},u} - \frac{1}{2}\LRp{ u, \Grad_h\cdot \Pi_N\LRp{\bm{\beta}u}} = \frac{1}{2}\LRp{-\LRp{\Grad \cdot \bm{\beta}} u,u},
\]
implying that $\frac{1}{2}\nor{u}^2 = 0$ if $\Grad\cdot \bm{\beta} = 0$, or that the method is energy conserving.  The only difference in this formulation is the introduction of $\Pi_N$, which can be defined at a discrete level using any quadrature scheme for which a discrete projection is well-defined. 

Penalization can be added by adding any positive-definite stabilization term (upwind, penalty, Lax-Friedrichs) through the regular divergence flux.  

\section{Discrete DG derivatives}

Methods based on discrete DG derivatives also work.  

The discrete DG derivative-based method is not consistent in the sense that Galerkin orthogonality does not hold exactly.  The difference lies in the flux terms.  Assume $\Div \bm{\beta} = 0$, then
\[
\LRp{\pd{u}{t},v} + \frac{1}{2}\LRp{-{ \bm{\beta}u},\Grad_h v} + \frac{1}{2}\LRp{\bm{\beta}\cdot\Grad_h u,v} = 0.
\]
\begin{align*}
\LRp{\Grad_h\cdot \Pi_N\LRp{ \bm{\beta}u},v} &= \sum_{k} \LRp{-\bm{\beta}u, \Grad v}_{\LK} + \LRa{\avg{\Pi_N\LRp{\bm{\beta} u}}\cdot \bm{n},v}_{\LdK}\\
\LRp{\Grad_h u,\bm{\beta}v} &= \sum_{k} \LRp{-u, \Grad \cdot \LRp{\bm{\beta}v}}_{\LK} + \LRa{\bm{\beta}\cdot\bm{n}\avg{u},v}_{\LdK}.
\end{align*}
The latter term is consistent; the former is not due to the presence of $\avg{\Pi_N\LRp{\bm{\beta} u}}\cdot \bm{n}$ in the flux term.  The consistency error should then be $O(h^{N+1/2})$ using a trace inequality for $L^2$ projections.  

Note: can also use interpolants in a stable manner if using $D_h$.  Unlike SEM, this still requires an extra matvec per RHS evaluation because of the lack of diagonality of the mass matrix.  Reduces number of steps by one (no interpolation to quadrature points) but does not reduce number of total matvecs.  

\subsection{Local conservation}

Writing this in non-conservative form raises the question of local conservation.  Integrating the original equation over $D^k$ and using Gauss' theorem gives
\[
\int_{D^k}\pd{u}{t} + \int_{\partial D^k} \beta_n u = 0.
\]
Taking $v = 1$ on $D^k$ yields
\[
\int_{D^k}\pd{u}{t} + \frac{1}{2}\LRp{\Grad_h\cdot \Pi_N \LRp{ \bm{\beta}u},\bbm{1}_{D^k}} + \frac{1}{2}\LRp{\bm{\beta}\cdot\Grad_h u,\bbm{1}_{D^k}} + \frac{1}{2}\LRp{\LRp{\Grad\cdot \bm{\beta}} u,\bbm{1}_{D^k}} = 0.
\]
The first term gives
\[
\LRp{\Grad_h\cdot \Pi_N \LRp{ \bm{\beta}u},\bbm{1}_{D^k}} = \int_{\partial D^k} \avg{\Pi_N\LRp{\bm{\beta}u}}\cdot\bm{n}.
\]
The second term gives
\[
\LRp{\bm{\beta}\cdot\Grad_h u,\bbm{1}_{D^k}} = \LRp{\Grad u,\bm{\beta}}_{D^k} + \frac{1}{2}\LRa{\jump{u},\bm{\beta}\cdot\bm{n}} = \LRp{u,-\Grad \cdot \bm{\beta}}_{D^k} + \LRa{\avg{u},\bm{\beta}\cdot\bm{n}}
\]
through integration by parts and an assumption that $\bm{\beta}\cdot \bm{n}$ is periodic.  Cancelling volume terms involving $\Grad\cdot \beta$, we end up with the statement of local conservation 
\[
\int_{D^k} \pd{u}{t}  + \frac{1}{2}\int_{\partial D^k} \LRp{\avg{\Pi_N\LRp{\bm{\beta}u}} + \LRp{\Pi_N\LRp{\bm{\beta}}\avg{u}}}\cdot\bm{n} = 0
\]
which is a discrete version of the continuous statement of local conservation.



\section{Non-affine mappings}
\label{sec:curv}

For general elements and curvilinear meshes, $J$ and $\bm{G}$ are no longer constant over each element.  However, for isoparametric mappings (and appropriate polynomial interpolations of general curvilinear mappings), metric identities hold \cite{kopriva2006metric} such that $\widehat{\Grad} \cdot \LRp{J\bm{G}^T} = 0$.  Thus, we can write
\[
\LRp{\Grad u,\bm{v}}_{D^k} = \LRp{J\bm{G}\widehat{\Grad} u,\bm{v}}_{\widehat{D}} = \LRp{-u,\widehat{\Grad} \cdot \LRp{J\bm{G}\bm{v}}}  + \LRa{J\bm{G}^T\widehat{\bm{n}} u,\bm{v}}.   
\]
Noting that $J\bm{G}\widehat{\bm{n}} = J^f \bm{n} $ \cite{hesthaven2007nodal}, we recover integration by parts over the physical element.  

Thus, to extend the discrete discontinuous Galerkin gradient and divergence to non-affine mappings, we simply define
\begin{align*}
\LRp{\widehat{\Grad}_h u,\bm{v}}_{\Omega} &= \sum_{k} \LRp{\widehat{\Grad}u,\bm{v}}_{\widehat{D}}  - \frac{1}{2}\LRa{\widehat{\bm{n}} \jump{u},\bm{v}} \\
\LRp{\widehat{\Grad}_h \cdot\bm{u},{v}}_{\Omega} &= \sum_{k} \LRp{\widehat{\Grad}\cdot \bm{u},{v}}_{\widehat{D}}  - \frac{1}{2}\LRa{\jump{\bm{u}},v\widehat{\bm{n}}} 
%\LRp{\Grad_h \cdot \bm{u},v}_{\Omega} &= \sum_{k} \LRp{\widehat{\Grad}\cdot{\Pi_N\LRp{J\bm{G}\bm{u}}},v}  - \frac{1}{2}\LRa{\widehat{\bm{n}} \jump{J\bm{G}\bm{u}},v} \\
%\LRp{\Grad_h u,\bm{v}}_{\Omega} &= \sum_{k} \LRp{\Pi_N\LRp{J\bm{G}\widehat{\Grad} u},\bm{v}}  - \frac{1}{2}\LRa{\widehat{\bm{n}} \jump{J\bm{G}u},v}.
\end{align*}
and define the discrete physical gradient and divergence as
\begin{align*}
\LRp{\Grad_h u,v}_{\Omega} &= \LRp{J\bm{G}\widehat{\Grad}_h u,\bm{v}}_{\Omega} = \sum_{k}\LRp{J\bm{G}\widehat{\Grad}u,\bm{v}}_{\widehat{D}}  - \frac{1}{2}\LRa{J\bm{G}\widehat{\bm{n}} \jump{u},\bm{v}} \\
\LRp{\Grad_h \cdot \bm{u},v}_{\Omega} &= \LRp{\widehat{\Grad}_h\cdot\LRp{J\bm{G}^T\bm{u}}}_{\Omega} = \sum_{k} \LRp{\widehat{\Grad}\cdot \LRp{J\bm{G}^T\bm{u}},{v}}_{\widehat{D}}  - \frac{1}{2}\LRa{\jump{J\bm{G}^T\bm{u}},v\widehat{\bm{n}}}. 
\end{align*}
The discrete gradient is consistent with the physical gradient.  The discrete divergence is also consistent with the physical divergence, provided that the jump term $\LRa{\jump{J\bm{G}^T\bm{u}},v\widehat{\bm{n}}}$ is computed via
\[
\LRa{\jump{J\bm{G}^T\bm{u}},v\widehat{\bm{n}}} = \LRa{\jump{J\LRp{\bm{G}\widehat{\bm{n}}}^T\bm{u}},v} = \LRa{\LRp{\widehat{\bm{n}}^T\LRp{J{\bm{G}}^T\bm{u}}}^+ + \LRp{\widehat{\bm{n}}^T\LRp{J{\bm{G}}^T\bm{u}}}^-,v}.  
\]

The advantage of this projected geometric factor approach is local conservation; taking $v = \bbm{1}_{D^k}$ recovers (after integration by parts) the flux integral
\[
\LRp{\Grad_h \cdot \bm{u},\bbm{1}_{D^k}}_{\Omega} = \int_{\partial D^k}\widehat{\bm{n}}^T\avg{J\bm{G}^T\bm{u}}.
\]

One downside of this approach is that stabilization must be applied separately from the discrete gradient.  We consider stabilization in the form of penalty fluxes.  For jump terms without normals, such as $\jump{p}$, these can be stabilized with no additional cost.  For terms involving normals, we often have $\jump{\bm{u}\cdot\bm{n}}\bm{n}$.  Since normals are rational functions for high order curvilinear mappings, these require quadrature to compute, and can be expensive.  An alternative approach would just be to use averaged normals instead, and combine them into the lifting within the reference element.  

\subsection{Specific discrete cases}

Spectral element methods and mass-lumpable tets: $\Pi_N = I_N$, and the lift operator is just the $\bm{B}$ boundary operator, which you can commute terms such that the scaling of the lift is the same as the lift of the scaling.  

CPR GL nodes: conservation for Burgers', but is this just because of the special nature of the flux function cancelling out other terms?  Skew-symmetric variable advection doesn't seem to be conservative.

\section{Extension to other hyperbolic problems}

Example: acoustic wave equation, simply discretize by replacing $\Grad, \Grad\cdot$ with discrete versions.  Automatically skew symmetric and energy stable via integration by parts.  Also, can show why WADG works: discretize based on discrete divergence, then test with $T_{c^2}^{-1}p$ and use identities.  Note - I think this requires the use of the strictly discrete version.  

Example: Burgers' equation

Example: Kinetic energy preserving splitting of Euler (assumes exact time discretization).  Doesn't seem to help much without extra viscosity?  

Example: Entropy splitting of Buckley-Leverett?

Example: Entropy splitting of Euler and Navier-Stokes - can do ``formally'', but the fluxes are singular and non-integrable.  

\section{Numerical experiments}

\begin{itemize}
\item Check ``true'' conservation of discrete DG differentiation formulations - does it converge at $h^{N+2}$ or greater?
\item Copy Ranocha's experiments.  
\item Convergence of 2D advection and (pre-shock) Burgers equation on curvilinear grids: conservative and Lax-Friedrichs fluxes.  
\item Stability (energy/entropy evolution) of 2D advection and Burgers equation on curvilinear grids: conservative and Lax-Friedrichs fluxes.  
\end{itemize}

%\section{Standard entropy stability estimates}
%
%Given a nonlinear conservation law
%\begin{align*}
%\pd{u}{t} + \pd{f(u)}{x} = 0
%\end{align*}
%DG formulation is usually
%\[
%\LRp{\pd{u}{t},v} + \LRp{D_h f,v} = 0.
%\]
%Taking $v = u$ gives
%\[
%\frac{1}{2}\nor{u}^2 + \int_{D^k}{u D_h f} = 0.
%\]
%Continuous entropy stability relies on the introduction of $F,G$ such that
%\[
%\pd{F}{u} = u\pd{f}{u}, \qquad \pd{G}{u} = f, \qquad F = uf - G.
%\]
%Then, relying on product and chain rules
%\[
%\int_{D^k}{u \pd{f}{x}} = \int_{D^k}{\pd{(uf)}{x} - f\pd{u}{x}} = \int_{D^k}{\pd{(uf)}{x} - \pd{G}{u}\pd{u}{x}} =  \int_{D^k}{\pd{\LRp{uf-G}}{x}} = \int_{D^k}{\pd{F}{x}} = \int_{\partial D^k} F.
%\]
%These boundary terms can be made to cancel with appropriately defined numerical fluxes, resulting in entropy conservative schemes.  The challenge in reproducing this in the discrete case is the lack of a product and chain rule for inexact quadratures.  Jameson deals with this by introducing an integrated flux
%\[
%G = \frac{1}{2}\int_{-1}^1 f \LRp{ \avg{u} + \theta \jump{u}} \diff \theta.
%\]
%for which finite volume schemes satisfy (in a rough sense)
%\[
%\jump{G} = \avg{G} \jump{u}.
%\]
%Fischer and Carpenter (also Gassner and co-workers) use a similar idea but combine a symmetric two-point flux approximation with properties of SBP matrices to get 
%\[
%2\LRp{W,DF} = \LRp{W,DF} - \LRp{DW,F} + \LRa{W,F} =  \sum_i \sum_j (W_i-W_j) (MD)_{ij} F(U_i,U_j) + \LRa{W,F}.
%\]
%
%\section{Entropy splitting}
%
%It's currently unclear how to extend the symmetric two-point flux approximation to quadrature-based DG methods.  

%Sandham and Yee use the entropy splitting 
%\[
%\eta(U) =  -\beta p^*, \qquad p^* = - \LRp{\frac{p}{\rho^\gamma}}^{\frac{1}{\beta(1-\gamma)}},
%\]
%which generates the entropy variables
%\[
%W(U) = p^*\LRp{\begin{array}{ccc}
%\frac{E}{p} - C, &\frac{-\rho u}{p}, &\frac{\rho}{p}
%\end{array}}, \qquad C = \frac{2}{\gamma-1} + (1+\beta).
%\]
%Unfortunately, the inverse mapping $U(W)$ is not explicitly known, which will greatly hamper computational efforts.  For example, this implies we cannot evolve the entropy variables explicitly, which would yield an energy estimate.  
%The Jacobian
%\[
%\pd{U}{W} = \LRs{
%d
%}, 
%\qquad \pd{W}{U} = \pd{U}{W}^{-1} = \LRs{
%}
%\]
%The flux Jacobian
%\[
%\pd{F}{U} = \LRs{\begin{array}{ccc}
%0 & u \frac{(\gamma-3)}{2} & \\
%1 & -u(\gamma-3) & 
%\end{array}}
%\]

\bibliographystyle{unsrt}
\bibliography{dg}


\end{document}


