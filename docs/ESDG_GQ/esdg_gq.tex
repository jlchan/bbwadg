\pdfoutput=1

%\documentclass[preprint,10pt]{elsarticle}
%\documentclass[preprint,10pt]{amsart}
%\documentclass[review, 10pt]{siamart0216}
%\documentclass{siamart0216}
\documentclass[review,onefignum,onetabnum,final]{siamart171218}

%\usepackage{fullpage}
%\usepackage[colorlinks=true]{hyperref}

\usepackage{amsmath,amssymb,amsfonts}
\newtheorem*{remark}{Remark}

%\usepackage{pdfpages}
\usepackage[titletoc,toc,title]{appendix}
\usepackage{listings}
\usepackage{array} 
\usepackage{mathtools}
\usepackage{bm}
\usepackage{bbm}

\usepackage{tikz}
\usepackage[normalem]{ulem}
\usepackage{hhline}

\usepackage{graphicx}
\usepackage{subfig}
\usepackage{color}

%% ====================================== graphics

\usepackage{pgfplots}
\usepackage{pgfplotstable}
\definecolor{markercolor}{RGB}{124.9, 255, 160.65}
\pgfplotsset{
compat=1.3,
width=10cm,
tick label style={font=\small},
label style={font=\small},
legend style={font=\small}
}

\usetikzlibrary{calc}
\usetikzlibrary{intersections} 

%%% START MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.
\newcommand{\logLogSlopeTriangle}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        \pgfmathsetmacro{\xArel}{#1}
        \pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{\yArel}
        \pgfmathsetmacro{\xCrel}{\xArel}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=0.5,anchor=north] {}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=west] {\textcolor{black}{#4}}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.

\newcommand{\logLogSlopeTriangleNeg}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        \pgfmathsetmacro{\xArel}{#1}
        \pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{\yArel}
        \pgfmathsetmacro{\xCrel}{\xArel}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=.5,anchor=south] {}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=west] {\textcolor{black}{#4}}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.

%%% START MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.
\newcommand{\logLogSlopeTriangleFlipNeg}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        %\pgfmathsetmacro{\xArel}{#1}
        %\pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{#3}
        \pgfmathsetmacro{\xCrel}{#1}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

	\pgfmathsetmacro{\xArel}{\xBrel}
        \pgfmathsetmacro{\yArel}{\yCrel}

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=0.5,anchor=east] {\textcolor{black}{#4}}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=north] {1}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.


%%% START MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.
\newcommand{\logLogSlopeTriangleFlip}[5]
{
    % #1. Relative offset in x direction.
    % #2. Width in x direction, so xA-xB.
    % #3. Relative offset in y direction.
    % #4. Slope d(y)/d(log10(x)).
    % #5. Plot options.

    \pgfplotsextra
    {
        \pgfkeysgetvalue{/pgfplots/xmin}{\xmin}
        \pgfkeysgetvalue{/pgfplots/xmax}{\xmax}
        \pgfkeysgetvalue{/pgfplots/ymin}{\ymin}
        \pgfkeysgetvalue{/pgfplots/ymax}{\ymax}

        % Calculate auxilliary quantities, in relative sense.
        %\pgfmathsetmacro{\xArel}{#1}
        %\pgfmathsetmacro{\yArel}{#3}
        \pgfmathsetmacro{\xBrel}{#1-#2}
        \pgfmathsetmacro{\yBrel}{#3}
        \pgfmathsetmacro{\xCrel}{#1}

        \pgfmathsetmacro{\lnxB}{\xmin*(1-(#1-#2))+\xmax*(#1-#2)} % in [xmin,xmax].
        \pgfmathsetmacro{\lnxA}{\xmin*(1-#1)+\xmax*#1} % in [xmin,xmax].
        \pgfmathsetmacro{\lnyA}{\ymin*(1-#3)+\ymax*#3} % in [ymin,ymax].
        \pgfmathsetmacro{\lnyC}{\lnyA+#4*(\lnxA-\lnxB)}
        \pgfmathsetmacro{\yCrel}{\lnyC-\ymin)/(\ymax-\ymin)} % THE IMPROVED EXPRESSION WITHOUT 'DIMENSION TOO LARGE' ERROR.

	\pgfmathsetmacro{\xArel}{\xBrel}
        \pgfmathsetmacro{\yArel}{\yCrel}

        % Define coordinates for \draw. MIND THE 'rel axis cs' as opposed to the 'axis cs'.
        \coordinate (A) at (rel axis cs:\xArel,\yArel);
        \coordinate (B) at (rel axis cs:\xBrel,\yBrel);
        \coordinate (C) at (rel axis cs:\xCrel,\yCrel);

        % Draw slope triangle.
        \draw[#5]   (A)-- node[pos=0.5,anchor=east] {\textcolor{black}{#4}}
                    (B)-- 
                    (C)-- node[pos=0.5,anchor=south] {}
                    cycle;
    }
}
%%% END MACRO FOR ANNOTATION OF TRIANGLE WITH SLOPE %%%.



\usepackage{stmaryrd}

\renewcommand{\tilde}{\widetilde}
\renewcommand{\hat}{\widehat}
%\renewcommand{\topfraction}{0.85}
%\renewcommand{\textfraction}{0.1}
%\renewcommand{\floatpagefraction}{0.75}

\newcommand{\vect}[1]{\ensuremath\boldsymbol{#1}}
\newcommand{\tensor}[1]{\underline{\bm{#1}}}
\newcommand{\del}{\triangle}
\newcommand{\curl}{\grad \times}
\renewcommand{\div}{\grad \cdot}

\newcommand{\bbm}[1]{\mathbbm{#1}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\equaldef}{\stackrel{\mathrm{def}}{=}}

\newcommand{\td}[2]{\frac{{\rm d}#1}{{\rm d}{\rm #2}}}
\newcommand{\pd}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\nor}[1]{\left\| #1 \right\|}
\newcommand{\LRp}[1]{\left( #1 \right)}
\newcommand{\LRs}[1]{\left[ #1 \right]}
\newcommand{\LRa}[1]{\left\langle #1 \right\rangle}
\newcommand{\LRb}[1]{\left| #1 \right|}
\newcommand{\LRc}[1]{\left\{ #1 \right\}}
\newcommand{\LRceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\LRl}[1]{\left. #1 \right|}
\newcommand{\pdd}[2]{\frac{\partial^2#1}{\partial#2^2}}
\newcommand{\pdn}[3]{\frac{\partial^{#3}#1}{\partial#2^{#3}}}
\newcommand{\mb}[1]{\mathbf{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\snor}[1]{\left| #1 \right|}


%\newcommand{\cond}[1]{\kappa\LRp{#1}}
\newcommand{\cond}[2]{\nor{#1}_{#2}\nor{{#1}^{-1}}_{#2}}


\newcommand{\Grad} {\ensuremath{\nabla}}
\newcommand{\Div} {\ensuremath{\nabla\cdot}}
\newcommand{\jump}[1] {\ensuremath{\llbracket#1\rrbracket}}
\newcommand{\avg}[1] {\ensuremath{\LRc{\!\{#1\}\!}}}

\newcommand{\Oh}{{\Omega_h}}
\renewcommand{\L}{L^2\LRp{\Omega}}
\newcommand{\LK}{L^2\LRp{D^k}}
\newcommand{\LdK}{L^2\LRp{\partial D^k}}
\newcommand{\Dhat}{\widehat{D}}
\newcommand{\Lhat}{L^2\LRp{\Dhat}}

\newcommand{\eval}[2][\right]{\relax
  \ifx#1\right\relax \left.\fi#2#1\rvert}

\def\etal{{\it et al.~}}


\newcommand{\note}[1]{{\color{blue}{#1}}}
%\newcommand{\noteOne}[1]{{\color{blue}{#1}}}
%\newcommand{\noteTwo}[1]{{\color{red}{#1}}}
%\newcommand{\note}[1]{#1}
%\newcommand{\noteOne}[1]{#1}
%\newcommand{\noteTwo}[1]{#1}


\newcommand{\LinfDk}{L^{\infty}\LRp{D^k}}
\newcommand{\diag}[1]{{\rm diag}\LRp{#1}}
\newcommand{\Ksub}{K_{\rm sub}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

%% d in integrand
\newcommand*\diff[1]{\mathop{}\!{\mathrm{d}#1}}

\makeatletter
\renewcommand\d[1]{\mspace{6mu}\mathrm{d}#1\@ifnextchar\d{\mspace{-3mu}}{}}
\makeatother

\newcommand*{\vertbar}{\rule[-1ex]{0.5pt}{2.5ex}}
\newcommand*{\horzbar}{\rule[.5ex]{2.5ex}{0.5pt}}

%\date{}
\author{Jesse Chan, David C.\ Del Rey Fernandez, Mark H.\ Carpenter}
\title{Efficient entropy stable Gauss collocation methods}
\graphicspath{{./figs/}}

\begin{document}

\maketitle

\begin{abstract}
The construction of high order entropy stable collocation schemes on quadrilateral and hexahedral elements has relied on the use of Gauss-Legendre-Lobatto collocation points \cite{fisher2013high, carpenter2014entropy, gassner2016split} and their equivalence with summation-by-parts (SBP) finite difference operators \cite{gassner2013skew}.  In this work, we show how to efficiently generalize the construction of semi-discretely entropy stable schemes on tensor product elements to Gauss points and generalized SBP operators.  Numerical experiments suggest that the use of Gauss points can significant improve accuracy on curved meshes.  
\end{abstract}

\section{Introduction}

%Time dependent nonlinear conservation laws are ubiquitous in computational fluid dynamics (CFD).  These conservation laws include the compressible Euler and Navier-Stokes equations, which govern compressible fluid behavior within aerospace applications, as well as the equations governing coastal flooding and geophysical flows (shallow water), and those describing astrophysical phenomena (magnetohydrodynamics).  The utility of these simulations depends both on the reliability and accuracy of numerical methods for the solution of the associated nonlinear partial differential equations (PDEs).  
Time dependent nonlinear conservation laws are ubiquitous in computational fluid dynamics (CFD), for which high order methods are increasingly of interest.  Such methods are more accurate per degree of freedom than low order methods, while also possessing much smaller numerical dispersion and dissipation errors.  This makes high order methods especially well suited to time-dependent simulations.  In this work, we focus specifically on discontinuous Galerkin methods on unstructured quadrilateral and hexahedral meshes.  These methods combine properties of high order approximations with the geometric flexibility of unstructured meshing.  %When paired with explicit time-stepping methods, high order DG and finite element methods are also well-suited for many-core and GPU computing \cite{klockner2009nodal, swirydowicz2017acceleration, wintermeyer2018entropy}.  

However, high order methods are notorious for being more prone to instability compared to low order methods \cite{wang2013high}.  This instability is addressed through various stabilization techniques (e.g.\ artificial viscosity, filtering, slope limiting).  However, these techniques often reduce accuracy to first or second order, and can prevent solvers from realizing the advantages of high order approximations.  Moreover, it is often not possible to prove that a high order scheme does not blow up even in the presence of stabilization.  This ambiguity can necessitate the re-tuning of stabilization parameters, as parameters which are both stable and accurate for one problem or discretization setting  may provide either too little or too much numerical dissipation for another.  

The instability of high order methods is rooted in the fact that discretizations of nonlinear conservation laws do not typically satisfy a discrete analogue of the conservation or dissipation of energy (entropy).  While the numerical dissipation present for low order methods serves as a stabilizing mechanism, the low of numerical dissipation in high order methods reveals the lack of an inherent statement of stability.  The dissipation of entropy serves as an energetic principle for nonlinear conservation laws \cite{dafermos2005compensated}, and requires the use of the chain rule in its proof.  The instability of high order methods is tied to the fact that, when discretizing systems of nonlinear PDEs, the chain rule does not typically hold at the discrete level.  

The lack of a chain rule was circumvented by using a non-standard ``flux differencing'' formulation \cite{fisher2013high, carpenter2014entropy, gassner2016split, gassner2017br1}, which is key to constructing semi-discretely entropy stable high order schemes on unstructured quadrilateral and hexahedral meshes.  Flux differencing replaces the derivative of the nonlinear flux with the discrete differentiation of an auxiliary quantity.  This auxiliary quantity is computed through the evaluation of a two-point entropy conservative flux \cite{tadmor1987numerical} using pairs of solution values at quadrature points.  These entropy stable schemes were later extended to non-tensor product elements using GLL-like quadrature points on triangles and tetrahedra \cite{chen2017entropy, crean2018entropy}.  More recently, the construction of efficient entropy stable schemes was extended to more arbitrary choices of basis and quadrature \cite{chan2017discretely, chan2018discretely}.  

While entropy stable collocation schemes have been constructed on Gauss-like quadrature points without boundary nodes \cite{crean2017high}, the inter-element coupling terms for such schemes introduce an ``all-to-all'' coupling between degrees of freedom on two neighboring elements.  These coupling terms require evaluating two-point fluxes between solution states at all collocation nodes on two neighboring elements, resulting in significantly more communication and computation compared to collocation schemes based on point sets containing boundary nodes.  This work introduces efficient and entropy stable inter-element coupling terms for Gauss collocation schemes which require only communication of face values between neighboring elements.  The construction of these terms follows the framework introduced in \cite{chan2017discretely, chan2018discretely} for triangles and tetrahedra.  

The main motivation for exploring tensor product (quadrilateral and hexahedral) elements is the significant reduction in the number of operations required compared to high order entropy stable schemes on simplicial meshes \cite{chan2017discretely, chan2018discretely}.  Entropy stability schemes on simplicial elements require evaluating two-point fluxes between solution states at all quadrature points on an element.  The number of quadrature points on a simplex scales as $O(N^d)$ in $d$ dimensions, and results in $O(N^{2d})$ two-point flux evaluations per element.  In contrast, entropy stable schemes on quadrilateral and hexahedral elements require only the evaluation of two-point fluxes along lines of nodes due to a tensor product structure, resulting in $O(N^{d+1})$ evaluations in $d$ dimensions.  

In Section~\ref{sec:0}, we briefly review the derivation of continuous entropy inequalities for systems of nonlinear conservation laws.  In Section~\ref{sec:1}, we describe how to construct entropy stable discretizations of nonlinear conservation laws using different quadrature points on affine tensor product elements.  In Section~\ref{sec:2}, we describe how to extend this construction to curvilinear elements, and Section~\ref{sec:3} presents numerical results which confirm the high order accuracy and stability of the proposed method for smooth, discontinuous, and under-resolved (turbulent) solutions of the compressible Euler equations in two and three dimensions.  

\section{A brief review of entropy stability theory}
\label{sec:0}

We are interested in methods for the numerical solution of systems of conservation laws in $d$ dimensions
\begin{equation}
\pd{\bm{u}}{t} + \sum_{i=1}^d \pd{\bm{f}_i\LRp{\bm{u}}}{x_i} = 0,
\label{eq:nonlinpde}
\end{equation}
where $\bm{u}$ denotes the conservative variables, $\bm{f}_i(\bm{u})$ are nonlinear fluxes, and $x_i$ denotes the $i$th coordinate.  Many physically motivated conservation laws admit a statement of stability involving a convex scalar entropy $S(\bm{u})$.  We first define the entropy variables $\bm{v}(\bm{u})$ to be the gradient of the entropy $S(\bm{u})$ with respect to the conservative variables 
\[
\bm{v} = \pd{S(\bm{u})}{\bm{u}}.  
\]
For a convex entropy, $\bm{v}(\bm{u})$ defines an invertible mapping from conservative to entropy variables.  We denote the inverse of this mapping (from entropy to conservative variables) by $\bm{u}(\bm{v})$.  

At the continuous level, it can be shown (for example, in \cite{dafermos2005compensated}) that vanishing viscosity solutions to (\ref{eq:nonlinpde}) satisfy the strong form of an entropy inequality 
\begin{gather}
\pd{S(\bm{u})}{t} + \sum_{i=1}^d \pd{F_i(\bm{u})}{x_i} \leq 0,
\label{eq:entropyineq}
\end{gather}
where $F_i$ denotes the $i$th scalar entropy flux function and $\psi_i(\bm{u})$ denotes the $i$th entropy potential
\[
F_i(\bm{u}) = \bm{v}^T\pd{\bm{f}_i}{x_i}, \qquad \psi_i(\bm{u}) = \bm{v}^T\bm{f}_i(\bm{u}) - F_i(\bm{u}). 
\]
Integrating (\ref{eq:entropyineq}) over a domain $\Omega$ and applying the divergence theorem yields an integrated entropy inequality
\begin{equation}
\int_{\Omega} \pd{S(\bm{u})}{t} + \int_{\partial \Omega} \sum_{i=1}^d \bm{n}_i \LRp{\bm{v}^T\bm{f}_i(\bm{u}) - \psi_i(\bm{u})} \leq 0,
\label{eq:weakentropyineq}
\end{equation}
where $\partial \Omega$ denotes the boundary of $\Omega$ and $\bm{n}_i$ denotes the $i$th component of the outward normal on $\partial \Omega$.  Roughly speaking, this implies that the time rate of change of entropy is less than or equal to the flux of entropy through the boundary.


\section{Entropy stable Gauss and Gauss-Legendre-Lobatto collocation methods}
\label{sec:1}

This focus of this paper is on entropy stable high order collocation methods which satisfy a semi-discrete version of the entropy inequality (\ref{eq:weakentropyineq}).  These methods collocate the solution at some choice of collocation nodes, and are applicable to tensor product meshes consisting of quadrilateral and hexahedral elements.  

Entropy stable collocation methods have largely utilized Gauss-Legendre-Lobatto (GLL) nodes \cite{fisher2013high, carpenter2014entropy, gassner2016split, gassner2017br1}, which contain points on the boundary.  The popularity of GLL nodes can be attributed in part to a connection made in \cite{gassner2013skew}, where it was shown by Gassner that collocation DG discretizations based on GLL nodes could be recast in terms of summation-by-parts (SBP) operators.  This equivalence allowed Gassner to leverage existing finite difference formulations to produce stable high order discretizations of the nonlinear Burgers' equation.  

GLL quadratures contain boundary points, which greatly simplifies the construction of inter-element coupling terms for entropy stable collocation schemes.  However, it is also known that the use of GLL quadrature within DG methods under-integrates the mass matrix, which can lead to solution ``aliasing'' and lower accuracy \cite{parsani2016entropy}.  In this work, we explore entropy stable collocation schemes based on Gauss quadrature points instead of GLL points.  

This comparison is motivated by the accuracy of each respective quadrature rule.  While $(N+1)$-point GLL quadrature rules are exact for polynomial integrands of degree $(2N-1)$, $(N+1)$-point Gauss quadrature rules are exact for polynomials of degree $(2N+1)$.  This higher accuracy of Gauss quadrature has been shown to translate to lower errors and slightly improved rates of convergence in simulations of wave propagation and fluid flow \cite{kopriva2010quadrature, hindenlang2012explicit, chan2015gpu}.  However, Gauss points have not been widely used to construct entropy stable discretizations due to the lack of efficient, stable, and high order accurate inter-element coupling terms, known as simultaneous approximation terms (SBP-SAT) in the finite difference literature \cite{fernandez2014review, crean2017high, fernandez2018simultaneous}.  SBP-SATs for Gauss points are non-compact, in the sense that they introduce all-to-all coupling between degrees of freedom on neighboring elements.  This results in greater communication between elements, as well as a significantly larger number of two-point flux evaluations and floating point operations.  

It is possible to realize the improved accuracy of Gauss points while avoiding non-compact SBP-SATs through a staggered grid formulation, where the solution is stored at Gauss nodes but interpolated to a set of higher degree $(N+2)$ GLL ``flux'' points for computation \cite{parsani2016entropy}.  Because GLL nodes include boundary points, compact and high order accurate SBP-SAT terms can be constructed for the flux points.  After performing computations on the flux points, the results are interpolated back to Gauss points and used to evolve the solution forward in time.  Figure~\ref{fig:nodesets} shows an illustration of GLL, staggered grid, and Gauss point sets for a 2D quadrilateral element.  

\begin{figure}
\centering
\subfloat[GLL nodes]{\includegraphics[width=.3\textwidth]{figs/sbp.png}}
\hspace{.5em}
\subfloat[Staggered grid nodes]{\includegraphics[width=.3\textwidth]{figs/staggered.png}}
\hspace{.5em}
\subfloat[Gauss nodes]{\includegraphics[width=.3\textwidth]{figs/gsbp.png}}
\caption{Examples of nodal sets under which efficient entropy stable schemes can be constructed.  This work focuses on the construction of efficient and accurate SBP-SAT terms for Gauss nodal sets.}
\label{fig:nodesets}
\end{figure}

The following sections will describe how to construct efficient high order entropy stable schemes using Gauss points.  These schemes are based on ``decoupled'' SBP operators introduced in \cite{chan2017discretely, chan2018discretely}, which are applicable to general choices of basis and quadrature.  By choosing a tensor product Lagrange polynomial basis and $(N+1)$ point Gauss quadrature rules, we recover a Gauss collocation scheme.  The high order accuracy and entropy stability of this scheme are direct results of theorems presented in  \cite{chan2017discretely, chan2018discretely}.  However, we will also present a different proof of entropy stability in one dimension for completeness.  

\subsection{Gauss nodes and generalized summation by parts operators}
\label{sec:gsbp}
We assume the solution is collocated at $(N+1)$ quadrature points $x_i$ with associated quadrature weights $w_i$.  We do not make any assumptions on the points, in order to accommodate both GLL and Gauss nodes using this notation.  The collocation assumption is equivalent to approximating the solution using a degree $N$ Lagrange basis $\ell_j(x)$ defined over the $(N+1)$ quadrature points.  

Let $\bm{D}$ denote the nodal differentiation matrix, and let $\bm{V}_f$ denote the $(N+1)\times 2$ matrix which interpolates polynomials at Gauss nodes to values at endpoints.  These two matrices are defined entrywise as
\[
\bm{D}_{ij} = \LRl{\pd{\ell_j}{x}}_{x = x_i}, \qquad \LRp{\bm{V}_f}_{i1} = \ell_i(-1), \qquad  \LRp{\bm{V}_f}_{i2} = \ell_i(1).
\]
We also introduce the diagonal matrix of quadrature weights $\bm{W}_{ij} = \delta_{ij} w_i$.  In this work, $\bm{W}$ is identical to the mass matrix, whose entries are evaluated as $L^2$ inner products of basis functions.  This equality holds so long as the basis functions are Lagrange polynomials and integrals are approximated using quadrature (either GLL or Gauss).  
%\[
%\bm{M}_{ij} = \int_{-1}^{1} \ell_j(x)\ell_i(x) = \sum_{k=1}^{N+1}  w_k\ell_j(x_k)\ell_i(x_k)  = \delta_{ij} w_i.  
%\]
It can be show that the mass and differentiation matrices for Gauss nodes fall under the class of generalized SBP (GSBP) operators \cite{fernandez2014generalized}.  
\begin{lemma}
\label{lemma:sbp}
$\bm{Q} = \bm{W}\bm{D}$ satisfies the generalized summation by parts property
\[
\bm{Q} = \bm{V}_f^T \bm{B} \bm{V}_f - \bm{Q}^T, \qquad \bm{B} = \begin{bmatrix}-1 & \\ & 1\end{bmatrix}.
\]
\end{lemma}
%\begin{proof}
The proof is a direct restatement of integration by parts, and can be found in \cite{ortleb2016kinetic, ortleb2017kinetic, ranocha2018generalised}.  
%We reproduce it here for completeness.  Let $\bm{u},\bm{v}$ be two arbitrary vectors, and let $u(x), v(x)$ denote the polynomials whose nodal values are given by $\bm{u},\bm{v}$.  Then, 
%\begin{align*}
%\bm{v}^T\bm{Q}\bm{u} &= \bm{v}^T\bm{W}\bm{D}\bm{u} = \int_{-1}^1 \pd{u}{x}v = \LRl{uv}_{-1}^1 - \int_{-1}^1 u\pd{v}{x} \\
%&= \LRp{\bm{V}_f \bm{v}}^T\bm{B}\bm{V}_f\bm{u} - \LRp{\bm{D}\bm{v}}^T\bm{W}\bm{u} = \bm{v}^T\bm{V}_f^T\bm{B}\bm{V}_f \bm{u} - \bm{v}^T\bm{Q}^T\bm{u},
%\end{align*}
%where we have used that $\bm{W}$ is diagonal and that $(N+1)$-point Gauss quadrature is exact for the above integrands.  Taking $\bm{v} = \bm{e}_i$ and $\bm{u} = \bm{e}_j$ for $i,j = 1,\ldots, N+1$ (where $\bm{e}_i$ denotes the $i$th canonical vector) completes the proof.  
%\end{proof}
Lemma~\ref{lemma:sbp} holds for both GLL and Gauss nodes, and switching between these two nodal sets simply results in a redefinition of the matrices $\bm{D}, \bm{V}_f$.  For example, because GLL nodes include boundary points, the interpolation matrix $\bm{V}_f$ reduces to a generalized permutation matrix which extracts the nodal values associated with the left and right endpoints.  %Lemma~\ref{lemma:sbp} can be extended directly to higher dimensions through a tensor product construction.  



%However, there are some properties which are exclusive to Gauss nodes.  
%\begin{lemma}
%Let $p(x)$ be a linear function with Gauss nodal values $\bm{p}$.  Then, the Gauss node operators satisfy the following summation by parts property
%\[
%\diag{\bm{p}} \bm{Q} = \bm{V}_f^T \bm{B}\diag{\bm{V}_f\bm{p}} \bm{V}_f - \bm{Q}^T\diag{\bm{p}},
%\]
%where $\bm{B}$ is the boundary matrix introduced in Lemma~\ref{lemma:sbp}.
%\label{lemma:vertexmapped}
%\end{lemma}
%\begin{proof}
%Due to the fact that Gauss quadrature is exact for polynomial integrands of degree $(2N+1)$, the proof is very similar to that of Lemma~\ref{lemma:sbp}.  Let $\bm{u}, \bm{v}$ be vectors and let $u(x),v(x)$ denote polynomials with associated nodal values.  Then, 
%\begin{align*}
%\bm{v}^T\diag{\bm{p}} \bm{Q}\bm{u} &= \int_{-1}^1 \pd{u}{x} pv = 
%\LRl{ u pv}_{-1}^1 - \int_{-1}^1 u \pd{(pv)}{x}.
%\end{align*}
%The latter integrand is a polynomial of degree $2N$
%\begin{align*}
%&= \LRp{\bm{V}_f\bm{v}}^T \bm{B} \diag{\bm{V}_f\bm{p}} \bm{V}_f\bm{u}  - \LRp{\bm{D}\diag{\bm{p}}\bm{v}}^T\bm{W}\bm{u}.
%\end{align*}
%\end{proof}
%
%Both Lemma~\ref{lemma:sbp} and \ref{lemma:vertexmapped} extend directly to higher dimensions through tensor products.  


\subsection{Existing entropy stable SBP-SATs for generalized SBP operators}
\label{sec:gsbpsat}

In this section, we will review the construction of semi-discretely entropy stable discretizations.  Entropy stable discretizations can be constructed by first introducing an entropy conservative scheme, then adding appropriate interface dissipation to produce an entropy inequality.  The construction of entropy conservative schemes relies on the existence of an two-point (dyadic) entropy conservative flux \cite{tadmor1987numerical}.  
\begin{definition}
\label{def:tadmor}
Let $\bm{f}_S(\bm{u}_L,\bm{u}_R)$ be a bivariate function which is symmetric and consistent with the flux function $\bm{f}(\bm{u})$
\begin{align*}
\bm{f}_S(\bm{u}_L,\bm{u}_R) = \bm{f}_S(\bm{u}_R,\bm{u}_L), \qquad \bm{f}_S(\bm{u},\bm{u}) = \bm{f}(\bm{u})
\end{align*}
The numerical flux $\bm{f}_S(\bm{u}_L, \bm{u}_R)$ is entropy conservative if, for entropy variables $\bm{v}_L = \bm{v}(\bm{u}_L), \bm{v}_R = \bm{v}(\bm{u}_R)$, the Tadmor ``shuffle'' condition is satisfied
\begin{align*}
\LRp{\bm{v}_L - \bm{v}_R}^T \bm{f}_S(\bm{u}_L,\bm{u}_R) = (\psi_L - \psi_R), \qquad \psi_L = \psi(\bm{v}(\bm{u}_L)), \quad \psi_R = \psi(\bm{v}(\bm{u}_R)).  
\end{align*}
\end{definition}

For illustrative purposes, we will prove a semi-discrete entropy inequality on a one-dimensional mesh consisting of two elements of degree $N$.  We assume both meshes are translations of a reference element  $[-1,1]$, such that derivatives with respect to physical coordinates are identical to derivatives with respect to reference coordinates.  The extension to multiple elements and variable mesh sizes is straightforward.  

The construction of entropy conservative schemes relies on appropriate SBP-SATs for Gauss collocation schemes \cite{fernandez2014review, crean2017high, fernandez2018simultaneous}.  Let the rows of $\bm{V}_f$ be denoted as $\bm{t}_L, \bm{t}_R$ 
\[
\bm{V}_f = \begin{bmatrix}
\horzbar & \bm{t}_L & \horzbar\\
\horzbar & \bm{t}_R & \horzbar
\end{bmatrix}, \qquad \LRp{\bm{t}_L}_j = \ell_j(-1), \qquad \LRp{\bm{t}_R}_j = \ell_j(1).
\]
The inter-element coupling terms in \cite{fernandez2014review, crean2017high, fernandez2018simultaneous} utilize a decomposition of the surface mass matrix $\bm{V}_f^T\bm{B}\bm{V}_f$ as  
\begin{equation}
\bm{V}_f^T\bm{B}\bm{V}_f 
= \bm{t}_R\bm{t}_R^T - \bm{t}_L\bm{t}_L^T.
%, \qquad \bm{V}_f = \begin{bmatrix}
%\bm{t}_L & \bm{t}_R
%\end{bmatrix}
\label{eq:bmatdecomp}
\end{equation}
The construction of entropy conservative schemes on multiple elements requires appropriate inter-element coupling terms (SBP-SATs) involving $\bm{t}_L, \bm{t}_R$.  We consider a two element mesh, and show how SBP-SATs can be interpreted as constructing a global SBP operator.  

Let $\bm{u}^1_N, \bm{u}^2_N$ denote nodal degrees of freedom of the vector valued solution $\bm{u}(x)$ on the first and second element, respectively.  To simplify notation, we assume that all following operators are defined in terms of Kronecker products, such that they are applied to each component of $\bm{u}^1_N, \bm{u}^2_N$.  
We first define the matrix 
\begin{equation}
\bm{S} = \bm{Q} - \frac{1}{2}\bm{V}_f^T\bm{B}\bm{V}_f.
\label{eq:Smat}
\end{equation}
It is straightforward to show (using Lemma~\ref{lemma:sbp}) that $\bm{S}$ is skew-symmetric.  We can now define an SBP operator $\bm{D}_h = \bm{W}_h^{-1}\bm{Q}_h$ over two elements
\begin{equation}
\bm{Q}_{h} = 
\underbrace{\begin{bmatrix}
\bm{S}  & \frac{1}{2}\bm{t}_R\bm{t}_L^T \\
- \frac{1}{2}\bm{t}_L\bm{t}_R^T & \bm{S}
\end{bmatrix}}_{\bm{S}_h}
+
\underbrace{\begin{bmatrix}
-\frac{1}{2}\bm{t}_L\bm{t}_L^T  & \\
 & \frac{1}{2} \bm{t}_R\bm{t}_R^T
\end{bmatrix}}_{\frac{1}{2}\bm{B}_h}
, \qquad 
\bm{W}_h = \begin{bmatrix}\bm{W} &\\
& \bm{W}
\end{bmatrix}.
%\bm{D}_h = \begin{bmatrix}\bm{W}^{-1} &\\
%& \bm{W}^{-1}
%\end{bmatrix}
% \bm{Q}_h.
\label{eq:gsbp}
\end{equation}
It can be shown that $\bm{D}_h$ is high order accurate such that, if $\bm{u}_h$ is a polynomial of degree $N$, it is differentiated exactly.  Straightforward computations show that $\bm{Q}_h$ also satisfies an SBP property $\bm{Q}_h + \bm{Q}_h^T = \bm{B}_h$.
%\[
%\bm{Q}_h + \bm{Q}_h^T = \bm{B}_h.
%\begin{bmatrix}
%-\bm{t}_L\bm{t}_L  & \\
% & \bm{t}_R\bm{t}_R
%\end{bmatrix}.
%\]


Ignoring boundary conditions, an entropy conservative scheme for (\ref{eq:nonlinpde}) on two elements can then be given as
\begin{gather}
\td{}{t}\bm{W}_h\bm{u}_h + 2\LRp{\bm{Q}_h \circ \bm{F}_S}\bm{1} = 0, \qquad \bm{u}_h = \begin{bmatrix}
\bm{u}^1_N\\
\bm{u}^2_N
\end{bmatrix} \label{eq:ESgsbp} \\
\LRp{\bm{F}_S}_{ij} = \bm{f}_S\LRp{\LRp{\bm{u}_h}_i,\LRp{\bm{u}_h}_j}, \qquad 1 \leq  i,j \leq 2(N+1). \nonumber
\end{gather}
where $\circ$ denotes the Hadamard product \cite{horn2012matrix}.  Multiplying (\ref{eq:ESgsbp}) by $\bm{v}_h^T = \bm{v}\LRp{\bm{u}_h}^T$ 
%\begin{align*}
%\bm{v}_h^T\td{}{t}\bm{W}_h\bm{u}_h + 2\bm{v}_h^T\LRp{\bm{Q}_h \circ \bm{F}_S}\bm{1} = 0
%\end{align*}
will yield a semi-discrete version of the conservation of entropy (mimicking (\ref{eq:weakentropyineq}) with the inequality replaced by an equality)
\begin{equation}
\label{eq:consentropyGSBP}
\td{}{t}\bm{W}_h S(\bm{u}_h) + \bm{v}_h^T\LRp{\bm{B}_h\circ \bm{F}_S}\bm{1} -\bm{1}^T\bm{B}_h\psi\LRp{\bm{u}_h} = 0.
\end{equation}
We refer to \cite{crean2017high,crean2018entropy} for the proof of (\ref{eq:consentropyGSBP}).  

The drawback of the SBP-SATs introduced in this section lies in the nature of the off-diagonal matrices $\bm{t}_R\bm{t}_L$ and $-\bm{t}_L\bm{t}_R$.  For Gauss nodes, these blocks are dense, which implies that inter-element coupling terms produce a non-compact stencil.  Evaluating (\ref{eq:ESgsbp}) requires computing two-point fluxes $\bm{f}_S$ between all nodes on two neighboring elements, which significantly increases both the computational work, as well as communication between neighboring elements.  The main goal of this work is to circumvent the all-to-all coupling of degrees of freedom introduced by the SBP-SATs described in this section, which can be done through the use of ``decoupled'' SBP operators.  

\subsection{Decoupled SBP operators}

Decoupled SBP operators were first introduced in \cite{chan2017discretely} and used to construct entropy stable schemes on simplicial elements.  These operators (and simplifications under a collocation assumption) are presented in a more general setting in \cite{chan2017discretely, chan2018discretely} and in Appendix~\ref{app:decoupled}.  In this section, decoupled SBP operators are introduced in one dimension for GLL and Gauss nodal sets.  

Decoupled SBP operators build upon the GSBP matrices $\bm{W}, \bm{Q}$, interpolation matrix $\bm{V}_f$, and boundary matrix $\bm{B}$ introduced in Section~\ref{sec:gsbp}.  The decoupled SBP operator $\bm{Q}_N$ is defined as the block matrix 
\begin{equation}
\bm{Q}_N  = \begin{bmatrix}
\bm{Q} - \frac{1}{2}\bm{V}_f^T\bm{B}\bm{V}_f & \frac{1}{2}\bm{V}_f^T\bm{B}\\
-\frac{1}{2}\bm{B}\bm{V}_f & \frac{1}{2}\bm{B}
\end{bmatrix}.
\label{eq:qndef}
\end{equation}
Lemma~\ref{lemma:sbp} and straightforward computations show that $\bm{Q}_N$ also satisfies the following SBP property
\begin{lemma}
\label{lemma:dsbp}
Let $\bm{Q}_N$ be defined through (\ref{eq:qndef}).  Then,
\[
\bm{Q}_N + \bm{Q}_N^T = \begin{bmatrix}
\bm{0} &\\
& \bm{B}
\end{bmatrix}.
\]
\end{lemma}

The matrix $\bm{Q}_N$ acts not only on volume nodes, but on both volume and surface nodes.  However, $\bm{Q}_N$ does not directly define an approximation to the derivative.  Let $f(x), g(x)$ denote two functions, and let $\bm{f}, \bm{g}$ denote the values of $f,g$ at interior nodal points.  We also define vectors $\bm{f}_N, \bm{g}_N$ denoting the values of $f,g$ at both interior and boundary points 
\begin{equation}
\bm{f}_N = \begin{bmatrix}
f\LRp{x_1}\\
\vdots\\
f\LRp{x_{N+1}}\\
f(-1)\\
f(1)
\end{bmatrix} = \begin{bmatrix}
\bm{f} \\
\bm{f}_f
\end{bmatrix}, \qquad
\bm{g}_N = \begin{bmatrix}
g\LRp{x_1}\\
\vdots\\
g\LRp{x_{N+1}}\\
g(-1)\\
g(1)
\end{bmatrix} = \begin{bmatrix}
\bm{g} \\
\bm{g}_f
\end{bmatrix}.
\label{eq:fg}
\end{equation}
Then, a polynomial approximation to $f\pd{g}{x}$ can be computed using $\bm{Q}_N$.  Let $\bm{u}$ denote the nodal values of the polynomial $u(x) \approx f\pd{g}{x}$.  These coefficients are computed via
\begin{equation}
\bm{W}\bm{u} = \begin{bmatrix}
\bm{I}\\
\bm{V}_f
\end{bmatrix}^T \diag{\bm{f}_N} \bm{Q}_N \bm{g}_N.
\label{eq:qn}
\end{equation}
The expression (\ref{eq:qn}) can be rewritten in ``strong'' form as follows
\begin{align*}
\bm{u} = \bm{W}^{-1}\begin{bmatrix}
\bm{I}\\
\bm{V}_f
\end{bmatrix}^T& \diag{\bm{f}_N} \bm{Q}_N \bm{g}_N \\
= \diag{\bm{f}}\bm{D}\bm{g} &+ \frac{1}{2}\diag{\bm{f}} \bm{W}^{-1} \bm{V}_f^T \bm{B}\LRp{\bm{g}_f - \bm{V}_f\bm{g}} \\
&+ \frac{1}{2}\bm{W}^{-1} \bm{V}_f^T\bm{B}\diag{\bm{f}_f} \LRp{\bm{g}_f - \bm{V}_f\bm{g}},
\end{align*}
where we have used the fact that diagonal matrices commute to simplify expressions.  The decoupled SBP operator $\bm{Q}_N$ can thus be interpreted as adding boundary corrections to the GSBP operator $\bm{D}$ in a skew-symmetric fashion.  

It was shown in \cite{chan2017discretely} that $\bm{u}$ is a high order accurate approximation to the quantity $f\pd{g}{x}$.  Both the generalized SBP operator $\bm{D}$ and the expression in (\ref{eq:qn}) involving the decoupled SBP operator recover exact derivatives of high order polynomials.  However, when applied to non-polynomial functions, the decoupled SBP operator $\bm{Q}_N$ improves accuracy near the boundaries.  Figure~\ref{fig:dsbpcorrect} illustrates this by using both operators to approximate the derivative of a Gaussian $e^{-4x^2}$.  The decoupled SBP operator results in an improved approximation near the boundary.  %This can be interpreted as  \cite{brenner2007mathematical}

\begin{figure}
\centering
\begin{tikzpicture}
\begin{axis}[
    width=.6\textwidth,
    xlabel={$x$ coordinate},
%    ylabel={$L^2$ errors}, 
%    xmin=.0125, xmax=.75,
    ymin=-2, ymax=2.25,
    legend pos=north east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GSBP, Decoupled SBP, Exact}    
]
\pgfplotsset{
cycle list={{blue, only marks, mark=*}, {blue}, {red, only marks,mark=square*},{red},{black,dashed}}
}
\addlegendimage{blue, mark=*}
\addlegendimage{red, mark=square*}
\addlegendimage{black, dashed}

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(-0.93247,-0.677965)(-0.661209,1.35632)(-0.238619,1.07263)(0.238619,-1.07263)(0.661209,-1.35632)(0.93247,0.677965)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(-1,-1.56577)(-0.959184,-1.00891)(-0.918367,-0.51366)(-0.877551,-0.0774098)(-0.836735,0.302464)(-0.795918,0.628585)(-0.755102,0.903575)(-0.714286,1.13006)(-0.673469,1.31065)(-0.632653,1.44798)(-0.591837,1.54466)(-0.55102,1.60333)(-0.510204,1.62659)(-0.469388,1.61708)(-0.428571,1.57742)(-0.387755,1.51022)(-0.346939,1.41812)(-0.306122,1.30372)(-0.265306,1.16966)(-0.22449,1.01856)(-0.183673,0.85303)(-0.142857,0.675704)(-0.102041,0.489201)(-0.0612245,0.296143)(-0.0204082,0.0991513)(0.0204082,-0.0991513)(0.0612245,-0.296143)(0.102041,-0.489201)(0.142857,-0.675704)(0.183673,-0.85303)(0.22449,-1.01856)(0.265306,-1.16966)(0.306122,-1.30372)(0.346939,-1.41812)(0.387755,-1.51022)(0.428571,-1.57742)(0.469388,-1.61708)(0.510204,-1.62659)(0.55102,-1.60333)(0.591837,-1.54466)(0.632653,-1.44798)(0.673469,-1.31065)(0.714286,-1.13006)(0.755102,-0.903575)(0.795918,-0.628585)(0.836735,-0.302464)(0.877551,0.0774098)(0.918367,0.51366)(0.959184,1.00891)(1,1.56577)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(-0.93247,-0.194074)(-0.661209,1.16978)(-0.238619,1.20913)(0.238619,-1.20913)(0.661209,-1.16978)(0.93247,0.194074)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(-1,-0.434491)(-0.959184,-0.303266)(-0.918367,-0.130624)(-0.877551,0.0698403)(-0.836735,0.286078)(-0.795918,0.507515)(-0.755102,0.724981)(-0.714286,0.930644)(-0.673469,1.11794)(-0.632653,1.28151)(-0.591837,1.41712)(-0.55102,1.5216)(-0.510204,1.59278)(-0.469388,1.62942)(-0.428571,1.63111)(-0.387755,1.59825)(-0.346939,1.53198)(-0.306122,1.43404)(-0.265306,1.30681)(-0.22449,1.15314)(-0.183673,0.976347)(-0.142857,0.78012)(-0.102041,0.568459)(-0.0612245,0.345602)(-0.0204082,0.115959)(0.0204082,-0.115959)(0.0612245,-0.345602)(0.102041,-0.568459)(0.142857,-0.78012)(0.183673,-0.976347)(0.22449,-1.15314)(0.265306,-1.30681)(0.306122,-1.43404)(0.346939,-1.53198)(0.387755,-1.59825)(0.428571,-1.63111)(0.469388,-1.62942)(0.510204,-1.59278)(0.55102,-1.5216)(0.591837,-1.41712)(0.632653,-1.28151)(0.673469,-1.11794)(0.714286,-0.930644)(0.755102,-0.724981)(0.795918,-0.507515)(0.836735,-0.286078)(0.877551,-0.0698403)(0.918367,0.130624)(0.959184,0.303266)(1,0.434491)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(-1,0.146525)(-0.959184,0.193522)(-0.918367,0.251752)(-0.877551,0.322529)(-0.836735,0.406852)(-0.795918,0.50522)(-0.755102,0.617438)(-0.714286,0.742415)(-0.673469,0.877994)(-0.632653,1.02082)(-0.591837,1.1663)(-0.55102,1.30861)(-0.510204,1.44089)(-0.469388,1.55553)(-0.428571,1.64452)(-0.387755,1.70003)(-0.346939,1.71492)(-0.306122,1.68342)(-0.265306,1.60163)(-0.22449,1.46805)(-0.183673,1.2839)(-0.142857,1.05327)(-0.102041,0.783025)(-0.0612245,0.482507)(-0.0204082,0.162994)(0.0204082,-0.162994)(0.0612245,-0.482507)(0.102041,-0.783025)(0.142857,-1.05327)(0.183673,-1.2839)(0.22449,-1.46805)(0.265306,-1.60163)(0.306122,-1.68342)(0.346939,-1.71492)(0.387755,-1.70003)(0.428571,-1.64452)(0.469388,-1.55553)(0.510204,-1.44089)(0.55102,-1.30861)(0.591837,-1.1663)(0.632653,-1.02082)(0.673469,-0.877994)(0.714286,-0.742415)(0.755102,-0.617438)(0.795918,-0.50522)(0.836735,-0.406852)(0.877551,-0.322529)(0.918367,-0.251752)(0.959184,-0.193522)(1,-0.146525)};
\end{axis}
\end{tikzpicture}

\caption{Degree $N= 5$ approximations of derivatives of a Gaussian $e^{-4x^2}$ using the generalized SBP operator $\bm{D}$ and the decoupled SBP operator $\bm{Q}_N$ via (\ref{eq:qn}). The colored circles and squares denote values at Gauss points.  }
\label{fig:dsbpcorrect}
\end{figure}


\subsection{An entropy stable Gauss collocation scheme based on decoupled SBP operators}

We can now construct an entropy conservative Gauss collocation scheme with compact SBP-SATs using decoupled SBP operators.  As in Section~\ref{sec:gsbpsat}, we will construct a Gauss collocation scheme and provide a proof of semi-discrete entropy conservation for a two-element mesh.  

%(see Figure~\ref{fig:twoelem})
%\note{Add pics of two-element mesh}

We first note that $\bm{B}$ can be trivially decomposed into the sum of two outer products as in (\ref{eq:bmatdecomp})
\begin{equation}
\bm{B} = \begin{bmatrix}
-1 & 0 \\
0 & 1
\end{bmatrix} = \bm{e}_R\bm{e}_R^T - \bm{e}_L\bm{e}_L^T, \qquad \bm{e}_L = \begin{bmatrix} 1\\0\end{bmatrix}, \qquad \bm{e}_R = \begin{bmatrix} 0\\1\end{bmatrix}.
\label{eq:bmatdecomp2}
\end{equation}
The vectors $\bm{e}_L, \bm{e}_R$ are related to $\bm{t}_L, \bm{t}_R$ through the interpolation matrix $\bm{V}_f$.  Because $\bm{t}_L, \bm{t}_R$ are rows of $\bm{V}_f$, $\bm{t}_L\bm{1} = \bm{t}_R\bm{1} = 1$.  This can be used to show, for example, that
\begin{equation}
\label{eq:et}
\bm{B}\bm{V}_f\bm{1} = \LRp{\bm{e}_R\bm{e}_R^T - \bm{e}_L\bm{e}_L}\bm{1} = \bm{e}_R-\bm{e}_L.
\end{equation}


We can define a decoupled SBP matrix $\bm{Q}_h$ over two elements as follows
\begin{align}
\bm{Q}_h =& \LRs{\begin{array}{cc|cc}
\bm{S} &  \frac{1}{2}\bm{V}_f^T\bm{B} & & \\
 -\frac{1}{2}\bm{B}\bm{V}_f & -\frac{1}{2}\bm{e}_L\bm{e}_L^T & & \frac{1}{2}\bm{e}_R\bm{e}_L^T\\
 \hline
&& \bm{S} & \frac{1}{2}\bm{V}_f^T\bm{B} \\
& -\frac{1}{2}\bm{e}_L\bm{e}_R^T & - \frac{1}{2}\bm{B}\bm{V}_f & \frac{1}{2}\bm{e}_R\bm{e}_R^T
\end{array}} \label{eq:decoupledsbp2elem}
\end{align}
We can also show that $\bm{Q}_h\bm{1} = 0$.  Using (\ref{eq:et}), we have that
\begin{align}
\bm{Q}_h\bm{1} &= \begin{bmatrix}
\LRp{\bm{S} + \frac{1}{2}\bm{V}_f^T\bm{B} }\bm{1}\\
\frac{1}{2}\bm{B}\bm{V}_f\bm{1} + \frac{1}{2}\LRp{\bm{e}_R-\bm{e}_L}\\
\LRp{\bm{S} + \frac{1}{2}\bm{V}_f^T\bm{B} }\bm{1}\\
\frac{1}{2}\bm{B}\bm{V}_f\bm{1} + \frac{1}{2}\LRp{\bm{e}_R-\bm{e}_L}
\end{bmatrix} 
= 
\begin{bmatrix}
\LRp{\bm{Q} - \frac{1}{2}\bm{V}_f^T\bm{B}\bm{V}_f + \frac{1}{2}\bm{V}_f^T\bm{B}\bm{V}_f}\bm{1}\\
\frac{1}{2}\bm{B}\LRp{-\bm{1} + \bm{1}}\\
\LRp{\bm{Q} - \frac{1}{2}\bm{V}_f^T\bm{B}\bm{V}_f + \frac{1}{2}\bm{V}_f^T\bm{B}\bm{V}_f}\bm{1}\\
\frac{1}{2}\bm{B}\LRp{-\bm{1} + \bm{1}}\\
\end{bmatrix} = \bm{0}.
\label{eq:Q1zero}
\end{align}
Here, we have used the definition of $\bm{B}$ in (\ref{eq:bmatdecomp2}), the fact that $\bm{V}_f\bm{1} = \bm{1}$ and $\bm{Q}\bm{1} = 0$ \cite{fernandez2014generalized}, and the definition of $\bm{S}$ in (\ref{eq:Smat}).  This property (\ref{eq:Q1zero}) will be used in the proof of entropy conservation.  

It can be helpful to split up $\bm{Q}_h$ into two matrices
\begin{gather*}
\bm{Q}_h = \bm{S}_h + \frac{1}{2}\bm{B}_h, \qquad
\bm{S}_h= \LRs{\begin{array}{cc|cc}
\bm{S} &  \frac{1}{2}\bm{V}_f^T\bm{B} & & \\
 - \frac{1}{2}\bm{B}\bm{V}_f &  & & \frac{1}{2}\bm{e}_R\bm{e}_L^T\\
 \hline
&& \bm{S} &  \frac{1}{2}\bm{V}_f^T\bm{B} \\
& -\frac{1}{2}\bm{e}_L\bm{e}_R^T &  - \frac{1}{2}\bm{B}\bm{V}_f &\\
\end{array}}\\
\bm{B}_h = \LRs{\begin{array}{cc|cc}
&  & & \\
 & -\bm{e}_L\bm{e}_L^T & & \\
 \hline
&&  &  \\
&  && \bm{e}_R\bm{e}_R^T\\
\end{array}}.
\end{gather*}
The matrix $\bm{S}_h$ is skew-symmetric, while the matrix $\bm{B}_h$ functions as a boundary operator which extracts boundary values over the two-element domain (i.e.\ $\bm{B}_h$ extracts a left boundary value from element 1 and a right boundary value from element 2).  Note that here, $\bm{B}_h$ is diagonal, unlike the boundary operator defined in Section~\ref{sec:gsbpsat}.  

The two-element decoupled SBP operator $\bm{Q}_h$ in (\ref{eq:decoupledsbp2elem}) is related to the GSBP operator in (\ref{eq:gsbp}) through a block interpolation matrix
\[
\bm{I}_h = \begin{bmatrix}
\bm{I} &\\
\bm{V}_f &\\
&\bm{I}\\
&\bm{V}_f\\
\end{bmatrix}, \qquad \bm{I}_h^T\bm{Q}_h\bm{I}_h = {\begin{bmatrix}
\bm{S}  & \frac{1}{2}\bm{t}_R\bm{t}_L^T \\
- \frac{1}{2}\bm{t}_L\bm{t}_R^T & \bm{S}
\end{bmatrix}}
+
{\begin{bmatrix}
-\frac{1}{2}\bm{t}_L\bm{t}_L^T  & \\
 & \frac{1}{2} \bm{t}_R\bm{t}_R^T
\end{bmatrix}}.
\]

Let $\bm{u}^1_N, \bm{u}^2_N$ denote the values of the conservative variables at Gauss points on elements 1 and 2, respectively, and let $\bm{u}_h$ denote their concatenation as defined in (\ref{eq:ESgsbp}).  Let $\bm{v}(\bm{u}^i_N)$ denote the evaluation of entropy variables at Gauss points on element $i$, and define the ``entropy-projected conservative variables'' $\tilde{\bm{u}}^1_f, \tilde{\bm{u}}^2_f$ by evaluating the conservative variables in terms of the  interpolated values of the entropy variables at element boundaries 
\[
\tilde{\bm{u}}^i_f = \bm{u}(\bm{v}^i_f), \qquad \bm{v}^i_f = \bm{V}_f\bm{v}(\bm{u}^i_N), \qquad i = 1,2. 
\]
We now introduce $\bm{u}_h = \begin{bmatrix}\bm{u}^1_N & \bm{u}^2_N\end{bmatrix}^T$ as the concatenated vector of solution values at Gauss points, and define $\bm{v}_h, \tilde{\bm{v}}$, and $\tilde{\bm{u}}$ as follows:  
\[
\bm{v}_h = \bm{v}\LRp{\bm{u}_h} = \bm{v}\LRp{\begin{bmatrix}
{\bm{u}^1_N}\\
{\bm{u}^2_N}
\end{bmatrix}}, \qquad \tilde{\bm{v}} = \bm{I}_h\bm{v}_h, \qquad \tilde{\bm{u}} = \bm{u}\LRp{\tilde{\bm{v}}} = 
%\bm{u}\LRp{
%\begin{bmatrix}
%\bm{I}\\
%\bm{V}_f 
%\end{bmatrix}\bm{v}
%}=
\begin{bmatrix}
\bm{u}^1_N \\
\tilde{\bm{u}}^1_f \\
\bm{u}^2_N \\
\tilde{\bm{u}}^2_f
\end{bmatrix}.  
\]
The term $\bm{v}_h$ corresponds to the vector of entropy variables at $\bm{u}_h$, while $\tilde{\bm{v}}$ corresponds to the concatenated vector of Gauss point values and interpolated boundary values $\bm{v}^i_f$ of the entropy variables.  The term $\tilde{\bm{u}}$ denotes the evaluation of the conservative variables in terms of $\tilde{\bm{v}}$.  

Finally, we define $\bm{F}_S$ as the matrix of evaluations of the two-point flux $\bm{f}_S$ at combinations of values of $\tilde{\bm{u}}$
\[
\LRp{\bm{F}_S}_{ij} = \bm{f}_S\LRp{\tilde{\bm{u}}_i,\tilde{\bm{u}}_j}, \quad 1\leq i,j \leq 2(N+3).
\]
Note that, due to the consistency of $\bm{f}_S$, the diagonal of $\bm{F}_S$ reduces to flux evaluations
\begin{equation}
\label{eq:diagFS}
\LRp{\bm{F}_S}_{ii} = \bm{f}_S\LRp{\tilde{\bm{u}}_i,\tilde{\bm{u}}_j} = \bm{f}\LRp{\tilde{\bm{u}}_i}.  
\end{equation}
We can now construct a semi-discretely entropy conservative formulation based on decoupled SBP operators:
\begin{theorem}
\label{thm:consentropy}
Let $\bm{Q}_h$ be defined by (\ref{eq:decoupledsbp2elem}), and let $\bm{u}_h$ denote the two-element solution of the following formulation
\begin{gather}
\label{eq:form}
\bm{W}_h \td{}{t} \bm{u}_h + \bm{I}_h^T\LRp{\bm{Q}_h \circ \bm{F}_S}\bm{1} = 0.
\end{gather}
Then, $\bm{u}_h$ satisfies a semi-discrete conservation of entropy
\begin{gather*}
\bm{1}^T\bm{W}_h\td{S(\bm{u}_h)}{t} + \bm{1}^T\bm{B}_h\LRp{\bm{v}_f^T\bm{f}(\tilde{\bm{u}}_f) - \psi\LRp{\tilde{\bm{u}}_f}} = 0\\
\bm{v}_f = \begin{bmatrix}
\bm{t}_L \bm{v}\LRp{\bm{u}_N^1}\\
\bm{t}_R \bm{v}\LRp{\bm{u}_N^2}
\end{bmatrix}, \qquad \tilde{\bm{u}}_f = \bm{u}(\bm{v}_f).
\end{gather*}
%Let $\circ$ denote the Hadamard product, and let $\tilde{\bm{u}}_f^+$ denote values of the entropy-projected conservative variables on neighboring elements.  Then, the formulation
%\begin{equation}
%\label{eq:form}
%\bm{W}\td{\bm{u}_N}{t} + 2 \begin{bmatrix}
%\bm{I}\\
%\bm{V}_f
%\end{bmatrix}^T\LRp{\bm{Q}_N \circ \bm{F}_S}\bm{1} + \bm{V}_f^T \bm{B} \LRp{\bm{f}_S\LRp{\tilde{\bm{u}}_f^+,\tilde{\bm{u}}_f} - \bm{f}(\bm{u})} = 0
%\end{equation}
%satisfies the quadrature form of the semi-discrete conservation of entropy
%\[
%\bm{1}^T\bm{W}\td{S(\bm{u}_N)}{t} + \bm{1}^T\bm{B} \LRp{\bm{v}_f^T\bm{f}(\tilde{\bm{u}}_f) - \psi_i\LRp{\tilde{\bm{u}}_f}} = 0.
%\]
\end{theorem}
\begin{proof}
The proof results from testing with $\bm{v}_h^T$.  Since $\bm{v}(\bm{u}) = \pd{S(\bm{u})}{\bm{u}}$ and $\bm{W}_h$ is diagonal, the time term yields
\[
\bm{v}_h^T\td{}{t}\bm{W}_h\bm{u}_h = \bm{1}^T \td{}{t}\bm{W}_h\diag{\bm{v}_h}\bm{u}_h = \bm{1}^T\td{}{t}\bm{W}_h S(\bm{u}_h).
\]
The spatial term can be manipulated as follows
\begin{align*}
2\bm{v}_h^T \bm{I}_h^T\LRp{\bm{Q}_h \circ \bm{F}_S}\bm{1} &= 2\LRp{\bm{I}_h\bm{v}_h}^T \LRp{\LRp{\bm{S}_h \circ \bm{F}_S}\bm{1} + \frac{1}{2}\LRp{\bm{B}_h \circ \bm{F}_S}\bm{1}}\\
&= \tilde{\bm{v}}^T\LRp{\bm{B}_h \circ \bm{F}_S}\bm{1} + \tilde{\bm{v}}^T \LRp{\bm{S}_h \circ \bm{F}_S}\bm{1} - \bm{1}^T \LRp{\bm{S}_h \circ \bm{F}_S}\tilde{\bm{v}},
\end{align*}
where we have used the skew-symmetry of $\bm{S}_h$ in the last step.  The boundary term reduces to 
\[
\tilde{\bm{v}}^T\LRp{\bm{B}_h \circ \bm{F}_S}\bm{1} = \bm{1}^T\bm{B}_h\tilde{\bm{v}}_f^T\bm{f}\LRp{\tilde{\bm{u}}},
\]
where we have used (\ref{eq:diagFS}) and the fact that $\bm{B}_h$ is diagonal.  Here, $\tilde{\bm{v}}_f^T\bm{f}\LRp{\tilde{\bm{u}}}$ denotes a vector whose entries are the inner product of $\tilde{\bm{v}}$ and $\bm{f}\LRp{\tilde{\bm{u}}}$ at face points.  

The volume terms can be manipulated using the definition of $\bm{F}_S$ and the Tadmor shuffle condition in Definition~\ref{def:tadmor}
\begin{align*}
\tilde{\bm{v}}^T \LRp{\bm{S}_h \circ \bm{F}_S} \bm{1} - \bm{1}^T \LRp{\bm{S}_h \circ \bm{F}_S}\tilde{\bm{v}} 
&= \sum_{ij} \LRp{\bm{S}_h}_{ij} \LRp{\tilde{\bm{v}}_i - \tilde{\bm{v}}_j}^T\bm{f}_S\LRp{\tilde{\bm{u}}_i,\tilde{\bm{u}}_j}\\
&= \sum_{ij} \LRp{\bm{S}_h}_{ij} \LRp{\psi\LRp{\tilde{\bm{u}}_i} - \psi\LRp{\tilde{\bm{u}}_j}}\\
&= \psi\LRp{\tilde{\bm{u}}}^T \bm{S}_h \bm{1}- \bm{1}^T \bm{S}_h \psi\LRp{\tilde{\bm{u}}} = 2\LRp{ \psi\LRp{\tilde{\bm{u}}}^T\bm{S}_h\bm{1}}.
\end{align*}
where we have again used the skew-symmetry of $\bm{S}_h$ in the last step.  Substituting $\bm{S}_h = \bm{Q}_h - \frac{1}{2}\bm{B}_h$ and using (\ref{eq:Q1zero}) yields
\[
2\LRp{ \psi\LRp{\tilde{\bm{u}}}^T\bm{S}_h\bm{1}} = \psi\LRp{\tilde{\bm{u}}}^T\LRp{2\bm{Q}_h - \bm{B}_h} \bm{1} =-\psi\LRp{\tilde{\bm{u}}}^T\bm{B}_h \bm{1}  = -\bm{1}^T\bm{B}_h \psi\LRp{\tilde{\bm{u}}}, 
\]
where we have used the symmetry of $\bm{B}_h$ in the last step.
\end{proof}

\begin{remark}
The proof of Theorem~\ref{thm:consentropy} follows directly from choosing either GLL or Gauss quadratures in Theorem 4 of \cite{chan2017discretely}.  The proof is reproduced here for clarity, as the two-element case illuminates the skew-symmetric nature and structure of the inter-element coupling more explicitly.  
\end{remark}

It is possible to convert the semi-discrete entropy equality in Theorem~\ref{thm:consentropy} to a semi-discrete entropy inequality by adding appropriate interface dissipation terms, such as Lax-Friedrichs or matrix dissipation \cite{winters2017uniquely}.  We note that these terms must be computed in terms of $\tilde{\bm{u}}_f$ in order to ensure a discrete dissipation of entropy \cite{chen2017entropy, chan2017discretely}.  

\section{Extension to higher dimensions and non-affine meshes}
\label{sec:2}

The formulation in Theorem~\ref{thm:consentropy} can be naturally extended to Cartesian meshes in higher dimensions through a tensor product construction.  We consider first the construction of higher dimensional differentiation matrices on a two-dimensional reference element $\hat{D}$, assuming a two dimensional tensor product grid of quadrature nodes (the construction of decoupled SBP operators in three dimensions is straightforward and similar to the two-dimensional case).  We then construct physical differentiation matrices on mapped elements $D^k$, through which we construct an entropy conservative scheme.  

Let $\bm{D}_{\rm 1D}, \bm{W}_{\rm 1D}$ denote the 1D differentiation and mass matrices, respectively, on on the reference interval $[-1,1]$.  Let ${\bm{W}}$ denote the 2D reference mass matrix, and let ${\bm{D}}^i$ denote the differentiation matrices with respect to the $i$th reference coordinate.  These matrices can be expressed in terms of Kronecker products  
\[
{\bm{D}}^1 = \bm{D}_{\rm 1D} \otimes \bm{I}_{N+1}, \qquad {\bm{D}}^2 = \bm{I}_{N+1} \otimes \bm{D}_{\rm 1D}, \qquad {\bm{W}} = \bm{W}_{\rm 1D} \otimes  \bm{W}_{\rm 1D}.
\]
where $\bm{I}_{N+1}$ denotes the $(N+1)\times (N+1)$ identity matrix.  %The extension to 3D is done similarly.  

We also construct higher dimensional face interpolation matrices.  Let $\bm{V}_{f, {\rm 1D}}$ denote the one-dimensional interpolation matrix, and let $\bm{B}_{\rm 1D}$ denote the boundary matrix defined in Lemma~\ref{lemma:sbp}.  For an appropriate ordering of face quadrature points, the two-dimensional face interpolation matrix $\bm{V}_f$ and reference boundary matrices ${\bm{B}}^1, {\bm{B}}^2$ can be expressed as the concatenation of Kronecker product matrices
\[
\bm{V}_f = \begin{bmatrix}
\bm{V}_{f, {\rm 1D}} \otimes \bm{I}_{2}\\
\bm{I}_{2} \otimes \bm{V}_{f, {\rm 1D}} 
\end{bmatrix}, \qquad 
{\bm{B}}^1 = \begin{bmatrix}
\bm{B}_{\rm 1D} \otimes \bm{I}_{2} & \\
& \bm{0}
\end{bmatrix}, \qquad 
{\bm{B}}^2 = \begin{bmatrix}
\bm{0} &\\
& \bm{I}_{2} \otimes \bm{B}_{\rm 1D} 
\end{bmatrix}.
\]
In three dimensions, the face interpolation matrix would be expressed as the concatenation of three Kronecker products involving $\bm{V}_{f, {\rm 1D}}$.  The higher dimensional differentiation and interpolation matrices $\bm{D}^i, \bm{V}_f$ can now be used to construct higher dimensional decoupled SBP operators.  Let ${\bm{Q}}^i_N$ denote the decoupled SBP operator for the $i$th coordinate on the reference element, where ${\bm{Q}}^i_N$ is defined as
\[
{\bm{Q}}^i_N = \begin{bmatrix}
{\bm{Q}}^i - \frac{1}{2}\bm{V}_f^T{\bm{B}}^i\bm{V}_f & \frac{1}{2}\bm{V}_f^T{\bm{B}}^i\\
-\frac{1}{2}{\bm{B}}^i\bm{V}_f & \frac{1}{2}{\bm{B}}^i
\end{bmatrix}, \qquad {\bm{Q}}^i = {\bm{W}}{\bm{D}}^i.
\]

Let the domain now be decomposed into non-overlapping elements $D^k$, such that $D^k$ is the image of $\hat{D}$ under a degree $N$ polynomial mapping $\bm{\Phi}^k$.  We define geometric terms ${G}^k_{ij}$ as scaled derivatives of reference coordinates $\hat{\bm{x}}$ with respect to physical coordinates $\bm{x}$
\[
{G}^k_{ij} = J^k\pd{\hat{x}_j}{\bm{x}_j},
\]
where $J^k$ is the determinant of the Jacobian of $\bm{\Phi}^k$.  We also introduce the face Jacobian $J^k_f$, which is computed from the mapping of a physical face to a reference face.  We define matrices over each physical element $D^k$ 
\begin{gather}
\bm{W}_k = \bm{W} \diag{\bm{J}^k}, \qquad \bm{B}^i_k = \bm{B}^i_N \diag{\bm{n}_i \circ\bm{J}^f } \nonumber\\
\bm{Q}^i_k = \frac{1}{2} \sum_{j=1}^d \LRp{\diag{{\bm{G}}^k_{ij}}\bm{Q}^i_N  + \bm{Q}^i_N \diag{{\bm{G}}^k_{ij}} } \label{eq:splitcurv},
\end{gather}
where we have discretized the curved differentiation matrix in split form \cite{nordstrom2006conservative}.  
Here, $\bm{J}^k$ denotes the vector of values of $J^k$ at volume quadrature points, ${\bm{G}}^k_{ij}$ denotes the vector of values of ${G}^k_{ij}$ at volume and face quadrature points, and $\bm{n}^k_i, \bm{J}^k_f$ denote the $i$th outward unit normal and $J^k_f$ at face quadrature points.  Then, an entropy conservative scheme in two dimensions is given as follows: 
\begin{theorem}
\label{thm:esdg2d}
Assume that $\bm{Q}^k\bm{1} = 0$, and that $D^k$ are mapped curvilinear elements.  Let $\bm{u}^k_N$ denote the solution on $D^k$ satisfying
\begin{gather*}
\sum_{k}\LRp{\bm{W}_k\td{\bm{u}^k_N}{t} + \sum_{i=1}^d \LRp{2\LRp{\bm{Q}^i_k\circ\bm{F}_S} + \bm{V}_f^T\bm{B}_k^i\bm{f}_S\LRp{{\tilde{\bm{u}}_f}^+,\tilde{\bm{u}}^k_f}}} = 0\\
\LRp{\bm{F}_S}_{ij} = \bm{f}_S\LRp{\tilde{\bm{u}}_i,\tilde{\bm{u}}_j}, \qquad \tilde{\bm{u}} = \begin{bmatrix}
\bm{u}^k_N\\
\tilde{\bm{u}}^k_f
\end{bmatrix}, \qquad \tilde{\bm{u}}^k_f = \bm{u}\LRp{\bm{v}^k_f}, \qquad 
\bm{v}^k_f = {\bm{V}_f\bm{v}\LRp{\bm{u}^k_N}},
\end{gather*}
where $\tilde{\bm{u}}^+$ denotes boundary values of the entropy-projected conservative variables on neighboring elements.  Then, $\bm{u}^k_N$ satisfies the discrete conservation of entropy 
\[
\sum_{k} \LRp{\bm{1}^T\bm{W}\td{\bm{u}^k_N}{t} + \sum_{i=1}^d\bm{1}^T\bm{B}^i\LRp{\bm{v}_f^T\bm{f}(\tilde{\bm{u}}_f) - \psi\LRp{\tilde{\bm{u}}_f}}} = 0.
\]
\end{theorem}
The proof is a special case of the proof of Theorem 1 in \cite{chan2018discretely}, with the quadrature rule taken to be a tensor product rule with $(N+1)$ Gauss (or GLL) points in each coordinate direction.  

\begin{remark}
The operator $\bm{Q}^i_k$  in (\ref{eq:splitcurv}) can be applied without needing to explicitly store geometric terms $G^k_{ij}$ at face quadrature points.  By using the structure of the boundary matrix $\bm{B}^i$, expressions involving geometric terms on faces can be replaced by expressions involving components of unit outward normals $\bm{n}_i$ on $D^k$.  
\end{remark}

We note that Theorem~\ref{thm:esdg2d} relies on the assumption that $\bm{Q}^k\bm{1} = 0$.  This condition is equivalent to ensuring that the scaled geometric terms ${\bm{G}}^k_{ij}$ satisfy a discrete geometric conservation law (GCL) \cite{carpenter2014entropy, gassner2017br1, crean2018entropy, chan2018discretely}.  For two-dimensional degree $N$ (isoparametric) mappings, the GCL is automatically satisfied.  However, in three dimensions, the GCL is not guaranteed to be satisfied at the discrete level, due to the fact that geometric terms for isoparametric mappings are polynomials of degree higher than $N$.  

It is possible to ensure the satisfaction of a discrete GCL by using a sub-parametric polynomial geometric mapping.  Let $N_{\rm geo}$ denote the degree of a polynomial geometric mapping.  In three dimensions, the exact geometric terms for a degree $N_{\rm geo}$ polynomial mapping are polynomials of degree $(2N_{\rm geo} - 2)$ \cite{kopriva2006metric, hindenlang2012explicit, crean2018entropy}.  If $(2N_{\rm geo}-2) \leq N$, or if $N_{\rm geo} \leq \left\lfloor\frac{N}{2}\right\rfloor + 1$, then the discrete GCL is automatically satisfied.  

For $N_{\rm geo} \geq \left\lfloor\frac{N}{2}\right\rfloor + 1$, modifications to the computation of geometric terms are required to ensure that the GCL is satisfied at the discrete level.  For general SBP operators, the discrete GCL can be enforced through the solution of a local least squares problem \cite{crean2018entropy}.  We take an alternative approach and  construct geometric terms using the approach of Kopriva \cite{kopriva2006metric}.  This construction takes advantage of the fact that GLL and Gauss collocation methods correspond to polynomial discretizations.  Kopriva's construction is based on rewriting the geometric terms as the reference curl of an interpolated auxiliary quantity
\begin{equation}
\label{eq:conscurl}
\begin{bmatrix}
\bm{G}^k_{1j}\\
\bm{G}^k_{2j}\\
\bm{G}^k_{3j}
\end{bmatrix} = \begin{bmatrix}
\LRp{-\hat{\Grad} \times I_N\LRp{z\hat{\Grad}y}}_j\\
\LRp{\hat{\Grad} \times I_N\LRp{z\hat{\Grad}x}}_j\\
\LRp{\hat{\Grad} \times I_N\LRp{x\hat{\Grad}y}}_j
\end{bmatrix}, \qquad j = 1,2,3.
\end{equation}
Here, $I_N$ denotes the polynomial interpolation operator using GLL nodes.  By interpolating the auxiliary quantity in (\ref{eq:conscurl}) using polynomial interpolation prior to applying the curl, the geometric terms are approximated by degree $N$ polynomials which satisfy the discrete GCL by construction.  These GCL-satisfying geometric terms can then be used to compute normal vectors.  For a watertight mesh, the constructed normal vectors are guaranteed to be continuous across faces \cite{chan2018discretely}.  %We note that this approach can also be adapted to more general geometric mappings (e.g.\ rational or superparametric).  These mappings can offer additional geometric accuracy, which can be advantageous for problems with wall boundary conditions \cite{toulorge2016optimizing, zwanenburg2017necessity}.  

To summarize, extending higher dimensional entropy stable Gauss collocation schemes to curved meshes requires the following steps: 
\begin{enumerate}
\item Construct polynomial approximations of the geometric terms using equation (\ref{eq:conscurl}) and interpolation at GLL nodes \cite{kopriva2006metric}.  
\item Evaluate approximate geometric terms at volume and surface points, and compute normal vectors in terms of the approximate geometric terms.  
\item Compute physical derivatives using the split form (\ref{eq:splitcurv}).  
\end{enumerate}
Apart from evaluating the GCL-satisfying geometric terms at separate volume and surface points, entropy stable Gauss collocation schemes are extended to curved meshes in the same manner as GLL and staggered-grid collocation schemes \cite{carpenter2014entropy, parsani2016entropy, chan2018discretely}.  


\section{Numerical results}
\label{sec:3}
The compressible Euler equations in $d$ dimensions are given as follows:
\begin{align*}
\pd{\rho}{t} &+ \sum_{j=1}^d \pd{\LRp{\rho \bm{u}_j}}{x_j} = 0,\\
\pd{\rho \bm{u}_i}{t} &+ \sum_{j=1}^d \pd{\LRp{\rho \bm{u}_i\bm{u}_j + p\delta_{ij} }}{x_j} = 0, \qquad i = 1,\ldots,d\\
\pd{E}{t} &+ \sum_{j=1}^d \pd{\LRp{\bm{u}_j(E+p)}}{x_j} = 0.\nonumber
\end{align*}
Here, $\rho$ is density, $\bm{u} = \LRp{\bm{u}_1, \ldots,\bm{u}_d}$ is the vector of velocities, and $E$ is the total energy.  The pressure $p$ and specific internal energy $\rho e$ are given by 
\[
p = (\gamma-1)\LRp{E - \frac{1}{2}\rho \LRb{\bm{u}}^2}, \qquad \rho e = E - \frac{1}{2}\rho \LRb{\bm{u}}^2, \qquad \LRb{\bm{u}}^2 = \LRp{\sum_{j=1}^d \bm{u}_j^2}.
\]

There exists an infinite family of suitable convex entropies for the compressible Euler equations \cite{harten1983symmetric}.  However, there is only a single unique entropy which appropriately treats the viscous heat conduction term in the compressible Navier-Stokes equations \cite{hughes1986new}.  This entropy $S(\bm{u})$ is given in $d$ dimensions by
\begin{equation*}
S(\bm{u}) = -\frac{\rho s}{\gamma-1},
\end{equation*}
where $s = \log\LRp{\frac{p}{\rho^\gamma}}$ is the physical specific entropy.  The entropy variables in $d$ dimensions are given by
\begin{align*}
v_1 &= \frac{\rho e (\gamma + 1 - s) - E}{\rho e}, \\
v_{1+i}&= \frac{\rho \bm{u}_i}{\rho e}, \qquad i = 1,\ldots, d,\\
v_{d+2} &= -\frac{\rho}{\rho e},
\end{align*}
while the conservation variables in terms of the entropy variables are given by
\begin{align*}
\rho &= -(\rho e) v_{d+2}, \\
 \rho \bm{u}_i &= (\rho e) v_{1+i}, \qquad i = 1,\ldots,d\\
 E &= (\rho e)\LRp{1 - \frac{\sum_{j=1}^d{v_{1+j}^2}}{2 v_{d+2}}},
\end{align*}
where the quantities $\rho e$ and $s$ in terms of the entropy variables are 
\begin{equation*}
\rho e = \LRp{\frac{(\gamma-1)}{\LRp{-v_{d+2}}^{\gamma}}}^{1/(\gamma-1)}e^{\frac{-s}{\gamma-1}}, \qquad s = \gamma - v_1 + \frac{\sum_{j=1}^d{v_{1+j}^2}}{2v_{d+2}}.
\end{equation*}
Explicit expressions for entropy conservative numerical fluxes in two dimensions  are given by Chandrashekar \cite{chandrashekar2013kinetic}
\begin{align*}
&f^1_{1,S}(\bm{u}_L,\bm{u}_R) = \avg{\rho}^{\log} \avg{u},& &f^1_{2,S}(\bm{u}_L,\bm{u}_R) = \avg{\rho}^{\log} \avg{v},&\\
&f^2_{1,S}(\bm{u}_L,\bm{u}_R) = f^1_{1,S} \avg{u} + p_{\rm avg},&  &f^2_{2,S}(\bm{u}_L,\bm{u}_R) = f^1_{2,S} \avg{u},&\nonumber\\
&f^3_{1,S}(\bm{u}_L,\bm{u}_R) = f^2_{2,S},& &f^3_{2,S}(\bm{u}_L,\bm{u}_R) = f^1_{2,S} \avg{v} + p_{\rm avg},&\nonumber\\
&f^4_{1,S}(\bm{u}_L,\bm{u}_R) = \LRp{E_{\rm avg} + p_{\rm avg}}\avg{u},& &f^4_{2,S}(\bm{u}_L,\bm{u}_R) = \LRp{E_{\rm avg} + p_{\rm avg} }\avg{v},& \nonumber
\end{align*}
where we have defined the auxiliary quantities 
\begin{gather}
p_{\rm avg} = \frac{\avg{\rho}}{2\avg{\beta}}, \qquad E_{\rm avg} = \frac{\avg{\rho}^{\log}}{2\avg{\beta}^{\log}\LRp{\gamma -1}}   + \frac{\nor{\bm{u}}^2_{\rm avg}}{2}, \label{eq:fluxaux} \\
 \nor{\bm{u}}^2_{\rm avg} = 2(\avg{u}^2 + \avg{v}^2) - \LRp{\avg{u^2} +\avg{v^2}} \nonumber.  
\end{gather}
Expressions for entropy conservative numerical fluxes for the three-dimensional compressible Euler equations can also be explicitly written as
\begin{gather*}
\bm{f}_{1,S} = \LRp{\begin{array}{c}
\avg{\rho}^{\log}\avg{u}\\
\avg{\rho}^{\log}\avg{u}^2 + p_{\rm avg}\\
\avg{\rho}^{\log}\avg{u}\avg{v}\\
\avg{\rho}^{\log}\avg{u}\avg{w}\\
(E_{\rm avg}+ p_{\rm avg})\avg{u}\\
\end{array}}, 
\qquad 
\bm{f}_{2,S} = \LRp{\begin{array}{c}
\avg{\rho}^{\log}\avg{v}\\
\avg{\rho}^{\log}\avg{u}\avg{v}\\
\avg{\rho}^{\log}\avg{v}^2 + p_{\rm avg}\\
\avg{\rho}^{\log}\avg{v}\avg{w}\\
(E_{\rm avg}+ p_{\rm avg})\avg{v}\\
\end{array}},\\
\bm{f}_{3,S} = \LRp{\begin{array}{c}
\avg{\rho}^{\log}\avg{w}\\
\avg{\rho}^{\log}\avg{u}\avg{w}\\
\avg{\rho}^{\log}\avg{v}\avg{w}\\
\avg{\rho}^{\log}\avg{w}^2 + p_{\rm avg}\\
(E_{\rm avg}+ p_{\rm avg})\avg{w}\\
\end{array}}.\nonumber
%&f^1_{1,S}(\bm{u}_L,\bm{u}_R) = \avg{\rho}^{\log} \avg{u},& &f^1_{2,S}(\bm{u}_L,\bm{u}_R) = \avg{\rho}^{\log} \avg{v},&\\
%&f^2_{1,S}(\bm{u}_L,\bm{u}_R) = f^1_{1,S} \avg{u} + p_{\rm avg},&  &f^2_{2,S}(\bm{u}_L,\bm{u}_R) = f^1_{2,S} \avg{u},&\nonumber\\
%&f^3_{1,S}(\bm{u}_L,\bm{u}_R) = f^2_{2,S},& &f^3_{2,S}(\bm{u}_L,\bm{u}_R) = f^1_{2,S} \avg{v} + p_{\rm avg},&\nonumber\\
%&f^4_{1,S}(\bm{u}_L,\bm{u}_R) = \LRp{\frac{p_{\rm avg}^{\log}}{\gamma -1} + p_{\rm avg} + \frac{\nor{\bm{u}}^2_{\rm avg}}{2}}\avg{u},& &f^4_{2,S}(\bm{u}_L,\bm{u}_R) = \LRp{\frac{p_{\rm avg}^{\log}}{\gamma -1} + p_{\rm avg} + \frac{\nor{\bm{u}}^2_{\rm avg}}{2}}\avg{v},& \nonumber
\end{gather*}
with auxiliary quantities 
\begin{align*}
p_{\rm avg} &= \frac{\avg{\rho}}{2\avg{\beta}}, \qquad E_{\rm avg} = \frac{\avg{\rho}^{\log}}{2(\gamma-1)\avg{\beta}^{\log}} + \frac{1}{2}\avg{\rho}^{\log}\nor{\bm{u}}^2_{\rm avg}\\
\nor{\bm{u}}^2_{\rm avg} &= 2(\avg{u}^2 + \avg{v}^2 + \avg{w}^2) - \LRp{\avg{u^2} +\avg{v^2} + \avg{w^2}}.\nonumber
\end{align*}

In all problems, we estimate the timestep size $dt$ using $J, J^f$, and degree-dependent $L^2$ trace constants $C_N$ 
\[
dt = C_{\rm CFL}\frac{ h}{C_N}, \qquad h = \frac{1}{{\nor{J^{-1}}_{L^{\infty}}}\nor{J^f}_{L^{\infty}}},
\]
where $C_{\rm CFL}$ is some user-defined CFL constant.  For isotropic elements, the ratio of $J$ to $J^f$ scales as the mesh size $h$, while $C_N$ captures the dependence of the maximum stable timestep on the polynomial degree $N$.  For hexahedral elements, $C_N$ varies depending on the choice of quadrature.  It was shown in \cite{chan2015gpu} that 
\[
C_N =\begin{cases}
 d\frac{N(N+1)}{2} & \text{for GLL nodes}\\
d\frac{(N+1)(N+2)}{2} & \text{for Gauss nodes}
\end{cases}.
\]
Thus, based on this rough estimate of the maximum stable timestep, GLL collocation schemes should be able to take a timestep which is roughly $(1 + 2/N)$ times larger than the maximum stable timestep for Gauss collocation schemes.  We do not account for this discrepancy in this work, and instead set the timestep for both GLL and Gauss collocation schemes based on the more conservative Gauss collocation estimate of $dt$.  %Unless stated otherwise, all experiments utilize $C_{\rm CFL} = .5$.  

Numerical results in 1D are similar to those presented in \cite{chan2017discretely}.  Thus, we focus on two and three dimensional problems and comparisons of entropy stable GLL and Gauss collocation schemes.  

\subsection{2D isentropic vortex problem}

We begin by examining high order convergence of the proposed methods in two dimensions using the isentropic vortex problem \cite{shu1998essentially, crean2017high}.  The analytical solution is 
\begin{align}
\rho(\bm{x},t) &= \LRp{1 - \frac{\frac{1}{2}(\gamma-1)(\beta e^{1-r(\bm{x},t)^2})^2}{8\gamma \pi^2}}^{\frac{1}{\gamma-1}}, \qquad p = \rho^{\gamma},\\
u(\bm{x},t) &= 1 - \frac{\beta}{2\pi} e^{1-r(\bm{x},t)^2}(y-y_0), \qquad v(\bm{x},t) = \frac{\beta}{2\pi} e^{1-r(\bm{x},t)^2}(y-y_0),\nonumber
\end{align}
where $u, v$ are the $x$ and $y$ velocity and $r(\bm{x},t) = \sqrt{(x-x_0-t)^2 + (y-y_0)^2}$.  Here, we take $x_0 = 5, y_0 = 0$ and $\beta = 5$.  

\begin{figure}
\centering
\subfloat[Lightly warped mesh]{\includegraphics[width=.475\textwidth]{figs/warp2d_a0312.png}}
\hspace{1em}
\subfloat[Moderately warped mesh]{\includegraphics[width=.475\textwidth]{figs/warp2d_a125.png}}\\
\subfloat[Heavily warped mesh]{\includegraphics[width=.45\textwidth]{figs/warp2d_a25.png}}
\caption{Lightly, moderately, and heavily warped meshes for $N=4, K= 16$.  }
\label{fig:warp2d}
\end{figure}

We solve on a periodic rectangular domain $[0, 20] \times [-5,5]$ until final time $T=5$, and compute errors over all all solution fields.  For a degree $N$ approximation, we approximate the $L^2$ error using an $(N+2)$ point Gauss quadrature rule.  We also examine the influence of element curvature for both GLL and Gauss collocation schemes by examining $L^2$ errors on a sequence of moderately and heavily warped curvilinear meshes (see Figure~\ref{fig:warp2d}).  These warpings are constructed by modifying nodal positions according to the following mapping
\begin{align*}
\tilde{x} &= x + \alpha\cos\LRp{\frac{\pi}{20}(x-10)}\cos\LRp{\frac{3\pi}{10}y}\\
\tilde{y} &= y + \alpha\sin\LRp{\frac{\pi}{5}(\tilde{x}-10)}\cos\LRp{\frac{\pi}{10}y}.
\end{align*}
The lightly warped mesh corresponds to $\alpha = 1/32$, the moderately warped mesh corresponds to $\alpha = 1/8$, and the heavily warped mesh corresponds to $\alpha = 1/4$.  All results are computed using $C_{\rm CFL} = 1/2$ and Lax-Friedrichs interface dissipation.  

%\begin{center}
%\begin{tabular}{|c || c ||c ||c ||c ||c ||c |}
%\hline
%& $N=2$ & $N=3$& $N=4$& $N=5$& $N=6$& $N=7$\\
%\hline\hline
%$h = 1/4$ & $1.229e{0}$ & $4.144e{-1}$ & $1.235e{-1}$ & $3.325e{-2}$ & $1.068e{-2}$ & $3.309e{-3}$ \\
%$h = 1/8$ & $2.366e{-1}$ & $4.122e{-2}$ & $4.393e{-3}$ & $9.701e{-4}$ & $1.333e{-4}$ & $1.678e{-5}$ \\
%$h = 1/16$ & $2.589e{-2}$ & $2.930e{-3}$ & $1.269e{-4}$ & $2.103e{-5}$ & $7.970e{-7}$ & $1.327e{-7}$   
%\end{tabular}
%\end{center}
\begin{figure}
\centering
\subfloat[Affine mesh]{
\begin{tikzpicture}
\begin{loglogaxis}[
    width=.5\textwidth,
    xlabel={Mesh size $h$},
    ylabel={$L^2$ errors}, 
%    xmin=.0125, 
    ymin=2.5e-8, ymax=5,
    legend pos=south east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GLL, Gauss}    
]
\pgfplotsset{
cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
}
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.22861)(0.0625,0.236646)(0.03125,0.0258883)(0.015625,0.00406122)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.553435)(0.0625,0.0625441)(0.03125,0.0117156)(0.015625,0.0022841)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.414449)(0.0625,0.0412224)(0.03125,0.00293039)(0.015625,0.000145701)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.25082)(0.0625,0.0198863)(0.03125,0.000673152)(0.015625,2.98263e-05)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.123516)(0.0625,0.00439285)(0.03125,0.000126852)(0.015625,5.61786e-06)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0768018)(0.0625,0.0020579)(0.03125,5.55322e-05)(0.015625,2.36108e-06)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0332509)(0.0625,0.000970148)(0.03125,2.10334e-05)(0.015625,2.60008e-07)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0151231)(0.0625,0.000454595)(0.03125,1.00203e-05)(0.015625,6.57796e-08)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0106752)(0.0625,0.000133284)(0.03125,7.97032e-07)(0.015625,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.00657096)(0.0625,9.22845e-05)(0.03125,3.60025e-07)(0.015625,NaN)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.00330917)(0.0625,1.67825e-05)(0.03125,1.32696e-07)(0.015625,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.00185273)(0.0625,1.21465e-05)(0.03125,1.14289e-07)(0.015625,NaN)};
\end{loglogaxis}
\end{tikzpicture}
}
\subfloat[Lightly warped mesh]{
\begin{tikzpicture}
\begin{loglogaxis}[
    width=.5\textwidth,
    xlabel={Mesh size $h$},
%    ylabel={$L^2$ errors}, 
%    xmin=.0125, 
    ymin=2.5e-8, ymax=5,
    legend pos=south east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GLL, Gauss}    
]
\pgfplotsset{
cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
}
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.2082)(0.0625,0.265357)(0.03125,0.0301118)(0.015625,0.00467693)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.555586)(0.0625,0.0773534)(0.03125,0.0129171)(0.015625,0.0024363)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.448878)(0.0625,0.0485323)(0.03125,0.00385418)(0.015625,0.000225396)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.287685)(0.0625,0.0190431)(0.03125,0.000721055)(0.015625,3.19095e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.122081)(0.0625,0.00694351)(0.03125,0.000224524)(0.015625,1.14555e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0731583)(0.0625,0.00213914)(0.03125,6.32128e-05)(0.015625,2.73037e-06)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0424351)(0.0625,0.00114569)(0.03125,3.59697e-05)(0.015625,5.09643e-07)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0215298)(0.0625,0.000523714)(0.03125,9.27521e-06)(0.015625,7.14031e-08)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0112838)(0.0625,0.000219049)(0.03125,1.84304e-06)(0.015625,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.00809138)(0.0625,8.23415e-05)(0.03125,3.95565e-07)(0.015625,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.00388316)(0.0625,2.55074e-05)(0.03125,2.68102e-07)(0.015625,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.00222029)(0.0625,1.33111e-05)(0.03125,9.72405e-08)(0.015625,NaN)};

\end{loglogaxis}
\end{tikzpicture}
}
\\
\subfloat[Moderately warped mesh]{
\begin{tikzpicture}
\begin{loglogaxis}[
    width=.5\textwidth,
    xlabel={Mesh size $h$},
    ylabel={$L^2$ errors}, 
%    xmin=.0125,
    ymin=2.5e-8, ymax=5,    
    legend pos=south east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GLL, Gauss}    
]
\pgfplotsset{
cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
}
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.64274)(0.0625,0.445945)(0.03125,0.0720148)(0.015625,0.0091066)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.882247)(0.0625,0.138116)(0.03125,0.0268145)(0.015625,0.0039945)};


\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.662165)(0.0625,0.146131)(0.03125,0.0234934)(0.015625,0.00105368)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.368084)(0.0625,0.0734059)(0.03125,0.00420438)(0.015625,9.19378e-05)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.349184)(0.0625,0.0508268)(0.03125,0.00234785)(0.015625,5.36192e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.183472)(0.0625,0.0127617)(0.03125,0.000251929)(0.015625,7.6013e-06)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.171986)(0.0625,0.0103578)(0.03125,0.000386834)(0.015625,5.76284e-06)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0924215)(0.0625,0.00276519)(0.03125,6.80528e-05)(0.015625,3.27246e-07)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0729963)(0.0625,0.00276104)(0.03125,4.11305e-05)(0.015625,2.36125e-07)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0378013)(0.0625,0.0007649)(0.03125,4.15848e-06)(0.015625,NaN)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.026577)(0.0625,0.000589552)(0.03125,5.3039e-06)(0.015625,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.0154563)(0.0625,0.000146207)(0.03125,8.83156e-07)(0.015625,NaN)};

\end{loglogaxis}
\end{tikzpicture}
}
\subfloat[Heavily warped mesh]{
\begin{tikzpicture}
\begin{loglogaxis}[
    width=.5\textwidth,
    xlabel={Mesh size $h$},
%    ylabel={$L^2$ errors}, 
%    xmin=.0125,
    ymin=2.5e-8, ymax=5,    
    legend pos=south east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GLL, Gauss}    
]
\pgfplotsset{
cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
}
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,2.08578)(0.0625,1.33668)(0.03125,0.433653)(0.015625,0.0721002)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.82833)(0.0625,0.746283)(0.03125,0.11006)(0.015625,0.0110115)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.74649)(0.0625,0.546097)(0.03125,0.0879841)(0.015625,0.0090851)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.39268)(0.0625,0.245852)(0.03125,0.0255562)(0.015625,0.00165226)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,1.06289)(0.0625,0.218361)(0.03125,0.0209471)(0.015625,0.000665425)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.740071)(0.0625,0.105075)(0.03125,0.003505)(0.015625,8.26421e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.695283)(0.0625,0.0996971)(0.03125,0.00390099)(0.015625,0.000118992)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.457324)(0.0625,0.0354479)(0.03125,0.000767746)(0.015625,1.95823e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.449493)(0.0625,0.0374955)(0.03125,0.000909834)(0.015625,7.70064e-06)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.274721)(0.0625,0.0120499)(0.03125,0.000157175)(0.015625,9.61243e-07)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.294238)(0.0625,0.0162153)(0.03125,0.000166829)(.015625,1.19661e-06)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.125,0.150916)(0.0625,0.00538908)(0.03125,2.79182e-05)};
\end{loglogaxis}
\end{tikzpicture}
}
\caption{$L^2$ errors for the 2D isentropic vortex at time $T=5$ for degree $N = 2,\ldots,7$ GLL and Gauss collocation schemes.}
\label{fig:err2d}
\end{figure}

Figure~\ref{fig:err2d} shows the $L^2$ errors for affine, moderately warped, and heavily warped meshes.  For affine meshes, Gauss collocation results in a lower errors than GLL collocation at all orders.  However, the difference between both schemes decreases as $N$ increases.  This is not too surprising: on a Cartesian domain, the discrete $L^2$ inner product resulting from GLL quadrature converges to exact $L^2$ inner product over the space of polynomials as $N$ increases \cite{quarteroni1994introduction}.  However, GLL and Gauss collocation differ more significantly on curved meshes.  For both moderately and heavily warped meshes, the errors for a degree $N$ Gauss collocation scheme are nearly identical to errors for a higher order GLL collocation scheme of degree $(N+1)$.  These results are in line with numerical experiments in \cite{parsani2016entropy}, which show that GLL collocation schemes lose one order of convergence in the $L^2$ norm on unstructured non-uniform meshes.  Both results show that increasing quadrature accuracy significantly reduces the effect of polynomial aliasing due to curved meshes and spatially varying geometric terms.  

We note that $L^2$ approximation estimates on curved meshes \cite{lenoir1986optimal, bernardi1989optimal, warburton2013low} assume that the mesh size is small enough to be in the asymptotic regime (such that asymptotic error estimates hold).  On curved meshes, this requires that the mesh is sufficiently fine to resolve both the solution and geometric mapping.   The numerical results in Figure~\ref{fig:err2d} suggest that, compared to Gauss collocation schemes, under-integrated GLL collocation schemes may require a much finer mesh resolution to reach the asymptotic regime.  

%\note{Investigate robustness with respect to mesh distortion: GLL vs GQ errors.  GQ is better for more curved meshes.  Note that there is little difference between bilinear/trilinear and high order curved.  }

\subsection{3D isentropic vortex problem}

As in two dimensions, we test the accuracy of the proposed scheme using an isentropic vortex solution adapted to three dimensions.  The solution is the extruded 2D vortex propagating in the $y$ direction, with an analytic expression given in \cite{williams2013nodal}
\begin{align*}
\rho(\bm{x},t) &= \LRp{1-\frac{(\gamma-1)}{2}\Pi^2}^{\frac{1}{\gamma-1}}\\
\bm{u}(\bm{x},t) &= \Pi \bm{r}, \\
E(\bm{x},t) &= \frac{p_0}{\gamma-1}\LRp{1-\frac{\gamma-1}{2}\Pi^2}^{\frac{\gamma}{\gamma-1}} + \frac{\rho}{2}\LRb{\bm{u}}.
\end{align*}
where $\bm{u} = (u,v,w)^T$ is the velocity vector and % $\Pi$, $\bm{r}$ are defined as
\[
\Pi = \Pi_{\max}e^{\frac{1-\bm{r}^T\bm{r}}{2}}, \qquad \bm{r} = \begin{pmatrix}
-(x_2-c_2-t)\\
x_1-c_1\\
0
\end{pmatrix}.
\]
We take $c_1 = c_2 = 5$, $p_0 = {1}/{\gamma}$, and $\Pi_{\max} = 0.4$, and solve on the domain $[0,10]\times [0,20]\times [0,10]$.  As in the 2D case, we also examine the effect of curvilinear mesh warping.  Following \cite{chan2018discretely}, we construct a curved warping of the initial Cartesian mesh by mapping nodes on each hexahedron to warped nodal positions $(\tilde{x},\tilde{y},\tilde{z})$ through the transformation
\begin{align*}
\tilde{\bm{x}} &= \bm{x} + \sin\LRp{\pi \frac{(x-5)}{5}}\sin\LRp{2\pi \frac{(y-10)}{10}}\sin\LRp{\pi \frac{(z-5)}{5}}.
\end{align*} 
On curved meshes, the geometric terms are constructed using the approach of Kopriva described in Section~\ref{sec:2}.  A $C_{\rm CFL} = .75$ is used for all experiments.  

Figure~\ref{fig:err3d} shows the $L^2$ errors for degrees $N = 2, 3, 4$.  As in the 2D case, Gauss collocation schemes produce smaller errors than GLL collocation schemes, especially on on curved meshes.  The difference between the two schemes on affine meshes is slightly more pronounced than in 2D.  The difference between the two schemes on curved meshes is qualitatively similar to the 2D case, with Gauss collocation achieving higher accuracy than GLL collocation schemes at all polynomial degrees and mesh resolutions.  %, which may be due to the specific curvilinear warping applied in this work.  

\begin{figure}
\centering
\subfloat[Affine mesh]{
\begin{tikzpicture}
\begin{loglogaxis}[
    width=.5\textwidth,
    xlabel={Mesh size $h$},
    ylabel={$L^2$ errors}, 
%    xmin=.0125, 
    ymin=1e-5, ymax=5,
    legend pos=north west, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GLL, Gauss}    
]
\pgfplotsset{
cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
}
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,2.62759)(0.125,0.728523)(0.0625,0.112225)(0.03125,0.018711)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,1.53203)(0.125,0.23283)(0.0625,0.0417033)(0.03125,0.00806707)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.934758)(0.125,0.191949)(0.0625,0.0119788)(0.03125,0.000558681)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.562488)(0.125,0.0864096)(0.0625,0.00268061)(0.03125,0.000136725)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.460425)(0.125,0.02445)(0.0625,0.000821249)(0.03125,4.67491e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.239027)(0.125,0.0077433)(0.0625,0.000219705)(0.03125,2.67589e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.138105)(0.125,0.00744055)(0.0625,0.000126057)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.0547127)(0.125,0.00242675)(0.0625,4.2962e-05)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.0489719)(0.125,0.000897467)(0.0625,2.55644e-05)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.0246519)(0.125,0.000324802)(0.0625,2.44009e-05)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.023319)(0.125,0.00021951)(0.0625,NaN)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.00801774)(0.125,7.39203e-05)(0.0625,NaN)(0.03125,NaN)};

\end{loglogaxis}
\end{tikzpicture}
}
%\subfloat[Sub-parametric mesh]{
%\begin{tikzpicture}
%\begin{loglogaxis}[
%    width=.5\textwidth,
%    xlabel={Mesh size $h$},
%%    ylabel={$L^2$ errors}, 
%%    xmin=.0125, 
%    ymin=1e-6, ymax=5,
%      legend pos=south east, legend cell align=left, legend style={font=\tiny},	
%    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
%    legend entries={GLL, Gauss}    
%]
%\pgfplotsset{
%cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
%}
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,2.80762)(0.125,0.951269)(0.0625,0.173495)(0.03125,0.0295367)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,1.89337)(0.125,0.366475)(0.0625,0.0599646)(0.03125,0.0133605)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,1.21946)(0.125,0.257914)(0.0625,0.0494569)(0.03125,0.00380144)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.708125)(0.125,0.139733)(0.0625,0.015052)(0.03125,0.000419943)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.594597)(0.125,0.100782)(0.0625,0.0051111)(0.03125,0.000186621)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.347316)(0.125,0.0351013)(0.0625,0.000702893)(0.03125,4.39052e-05)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.306622)(0.125,0.0198205)(0.0625,0.00156957)(0.03125,NaN)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.142279)(0.125,0.00620177)(0.0625,0.000311399)(0.03125,NaN)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.130865)(0.125,0.0108333)(0.0625,0.000188656)(0.03125,NaN)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.0518407)(0.125,0.00289859)(0.0625,3.71549e-05)(0.03125,NaN)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.0558827)(0.125,0.00251998)(0.0625,NaN)(0.03125,NaN)};
%\addplot+[semithick, mark options={solid, fill=markercolor}]
%coordinates{(0.25,0.0208791)(0.125,0.000423102)(0.0625,NaN)(0.03125,NaN)};
%\end{loglogaxis}
%\end{tikzpicture}
%}\\
\subfloat[Curved mesh]{
\begin{tikzpicture}
\begin{loglogaxis}[
    width=.5\textwidth,
    xlabel={Mesh size $h$},
    ylabel={$L^2$ errors}, 
%    xmin=.0125, 
    ymin=1e-5, ymax=5,
    legend pos=north west, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={GLL, Gauss}    
]
\pgfplotsset{
cycle list={{blue, mark=*}, {red, dashed ,mark=square*}}
}
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,2.93541)(0.125,1.00445)(0.0625,0.18488)(0.03125,0.0323814)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,1.99429)(0.125,0.423426)(0.0625,0.0787544)(0.03125,0.0173475)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,1.23231)(0.125,0.266638)(0.0625,0.0513328)(0.03125,0.00390276)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.727022)(0.125,0.148442)(0.0625,0.0158392)(0.03125,0.000446109)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.599851)(0.125,0.101098)(0.0625,0.00511836)(0.03125,0.00018702)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.351163)(0.125,0.0353206)(0.0625,0.000705351)(0.03125,4.41811e-05)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.310649)(0.125,0.0199095)(0.0625,0.00157312)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.144996)(0.125,0.00619848)(0.0625,0.000311659)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.130579)(0.125,0.0108408)(0.0625,0.000188745)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.0517392)(0.125,0.00290387)(0.0625,3.71606e-05)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.0558635)(0.125,0.00251764)(0.0625,NaN)(0.03125,NaN)};
\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0.25,0.020886)(0.125,0.000421991)(0.0625,NaN)(0.03125,NaN)};
\end{loglogaxis}
\end{tikzpicture}
}
\caption{$L^2$ errors for the 3D isentropic vortex for $N = 2,\ldots,7$ on sequences of Cartesian and curved meshes.}
\label{fig:err3d}
\end{figure}

We also compared $L^2$ errors for both isoparametric and sub-parametric geometric mappings.  For sub-parametric mappings, we chose the degree of approximation of geometry $N_{\rm geo} = \left\lfloor\frac{N}{2} \right\rfloor + 1$, such that the geometric terms are computed exactly and the GCL is satisfied by default.   This test is intended to address the fact that the GCL-preserving interpolation of Kopriva introduces a small approximation error, as the geometric terms are no longer exact.  For these sub-parametric mappings, the gap between GLL and Gauss collocation widens slightly at $N=2$.  However, the results for sub-parametric mappings are nearly identical to the results in the isoparametric case for higher polynomial degrees.  


\subsection{Shock-vortex interaction}

The next problem considered is the shock-vortex interaction described in \cite{shu1998essentially}.  The domain is taken to be $[0,2]\times [0,1]$, and is triangulated with uniform quadrilateral elements.  Wall boundary conditions are imposed on the top and bottom boundaries, and inflow boundary conditions are typically imposed on the left and right boundaries.  We modify the problem setup such that periodic boundary conditions are imposed at the left and right boundaries.  Wall boundary conditions are imposed using a mirror state for the normal velocity, which was shown to be entropy stable in \cite{svard2014entropy, chen2017entropy}.  

The initial condition is taken to be the superposition of a stationary shock and a vortex propagating towards the right.  The stationary Mach $M_s = 1.1$ shock is positioned at $x = .5$ normal to the $x$ axis, with left state $\LRp{\rho_L, u_L, v_L, p_L} = \LRp{1, \sqrt{\gamma}, 0, 1}$.  The right state is a scaling of the left state computed using the Rankine-Hugoniot conditions, such that the ratio of upstream and downstream states is
%$\LRp{\rho_R, u_R, v_R, p_R} = \LRp{\rho_L/ \alpha_\rho, u_L / \alpha_u, 0, p_L/\alpha_p}$, where
\begin{align*}
\frac{\rho_L}{\rho_R} = \frac{u_L}{u_R} = \frac{2+ (\gamma-1) M_s^2}{(\gamma+1)M_s^2}, \qquad \frac{p_L}{p_R} = 1+ \frac{2\gamma}{\gamma+1}\LRp{M_s^2-1}, \qquad v_R = 0.
\end{align*}
The isentropic vortex is centered at $(x_c,y_c) = (.25, .5)$ and given in terms of velocity fluctuations $\delta u$ and $\delta v$, which are functions of the tangential velocity $v_{\theta}$
\[
\delta u = v_{\theta} \sin(\theta), \qquad
\delta v = -v_{\theta} \cos(\theta), \qquad
v_{\theta} = \epsilon \tau e^{\alpha(1-\tau^2)},
%u = \epsilon \tau e^{\alpha(1-\tau^2)}\sin(\theta), \qquad
%v = -\epsilon \tau e^{\alpha(1-\tau^2)}\cos(\theta), \qquad
%\delta T = -\frac{(\gamma-1)\epsilon^2e^{2\alpha(1-\tau^2)}}{4\alpha\gamma}.
\]
where $r = \sqrt{(x-x_c)^2 + (y-y_c)^2}$ is the radius from the vortex center, $\tau = r/r_c$, and $\theta = \tan^{-1}\LRp{\frac{y-y_c}{x-x_c}}$.  We follow \cite{shu1998essentially} and take $\epsilon = .3$, $\alpha = .204$, and $r_c = .05$.  The vortex temperature is computed as a fluctuation $\delta T$ of the upstream state $T_L = p_L/\rho_L$
\[
\delta T =  - \frac{(\gamma-1)\epsilon^2 e^{2\alpha (1-\tau^2)}}{4\alpha\gamma}.  
\]
The vortex density and pressure are computed using an isentropic assumption.  To summarize, the initial condition for the shock-vortex interaction problem is 
\begin{gather*}
\rho = \rho_s \LRp{\frac{T_{\rm vor}}{T_L}}^{\frac{1}{\gamma-1}}, \qquad u = u_s + \delta u, \qquad v = v_s + \delta v, \qquad p = p_s \LRp{\frac{T_{\rm vor}}{T_L}}^{\frac{1}{\gamma-1}},
\end{gather*}
where $(\rho_s,  u_s, v_s, p_s)$ denote the discontinuous stationary shock solution given by the left and right states $\LRp{\rho_L, u_L, v_L, p_L}, \LRp{\rho_R, u_R, v_R, p_R}$.  

\begin{figure}
\centering
\subfloat[Entropy conservative flux, $T = .3$]{\includegraphics[width=.495\textwidth]{figs/shockVortexTp3_EC.png}}
\hspace{.05em}
\subfloat[Entropy conservative flux, $T = .7$]{\includegraphics[width=.495\textwidth]{figs/shockVortexTp7_EC.png}}\\
\subfloat[Lax-Friedrichs flux, $T = .3$]{\includegraphics[width=.495\textwidth]{figs/shockVortexTp3_LF.png}}
\hspace{.05em}
\subfloat[Lax-Friedrichs flux, $T = .7$]{\includegraphics[width=.495\textwidth]{figs/shockVortexTp7_LF.png}}\\
\subfloat[Matrix dissipation flux, $T = .3$]{\includegraphics[width=.495\textwidth]{figs/shockVortexTp3.png}}
\hspace{.05em}
\subfloat[Matrix dissipation flux, $T = .7$]{\includegraphics[width=.495\textwidth]{figs/shockVortexTp7.png}}
\caption{Shock vortex solution at time $T = .7$ using entropy stable Gauss collocation schemes with $N=4, h = 1/100$.}
\label{fig:shockvort}
\end{figure}

We compare three different entropy stable Gauss collocation schemes.  All three utilize the entropy conservative flux of Chandrashekar \cite{chandrashekar2013kinetic}.  For the first scheme, we do not introduce any additional interface dissipation, which produces an entropy conservative scheme.  The second scheme introduces an entropy-dissipative interface term using Lax-Friedrichs penalization, while the third scheme utilizes the matrix dissipation flux introduced in \cite{winters2017uniquely}.  This flux adds a dissipation of the form $\bm{R}\bm{D}\bm{R}^T\jump{{\bm{v}}^k_f}$, where $\jump{{\bm{v}}^k_f}$ denotes the jump in the entropy variables.  In two dimensions, the matrices $\bm{R}, \bm{D}$ are 
\begin{align*}
\bm{R} &= \begin{bmatrix}
1 & 1 & 0 & 1\\
\avg{u}-\bar{a} n_x & \avg{u} & n_y & \avg{u}+\bar{a} n_x\\
\avg{v}-\bar{a} n_y & \avg{v} & -n_x & \avg{v}+\bar{a} n_y\\
h-\bar{a} \bar{u}_n & \frac{1}{2}\nor{\bm{u}}^2_{\rm avg} & \bar{u}_n n_y - \avg{v}n_x & h + \bar{a} \bar{u}_n
\end{bmatrix}\\
\bm{D} &= {\rm diag}{\begin{pmatrix}
\LRb{\bar{u}_n - a}\frac{\avg{\rho}^{\log}}{2\gamma}, & \LRb{\bar{u}_n}\frac{\avg{\rho}^{\log}(\gamma-1)}{\gamma}, & \LRb{\bar{u}_n}p_{\rm avg}, & \LRb{\bar{u}_n + a}\frac{\avg{\rho}^{\log}}{2\gamma} \end{pmatrix}},
\end{align*}
where $\bar{a}, \bar{u}_n$ are defined as
\begin{gather*}
\bar{u}_n = \avg{u}n_x + \avg{v}n_y, \qquad \bar{a} = \sqrt{\frac{\gamma p_{\rm avg}}{\avg{\rho}^{\log}}}, \qquad h = \frac{\gamma}{2(\gamma-1)\avg{\beta}^{\log}} + \frac{1}{2}\bar{u}, 
\end{gather*}
and $p_{\rm avg}, \nor{\bm{u}}^2_{\rm avg}$ are defined as in (\ref{eq:fluxaux}).  

%It is known that the Lax-Friedrichs flux is fairly dissipative compared to more nuanced fluxes \cite{harten1983upstream}, though this dissipation is less pronounced at higher polynomial degrees in practice.  
Figure~\ref{fig:shockvort} shows solutions for with $N=4$ and $h = 1/100$ Gauss collocation schemes using a non-dissipative entropy conservative flux, a dissipative Lax-Friedrichs flux, and a matrix dissipation flux.  In all cases, the vortex passes through the shock stably without the use of additional slope limiting, filtering, or artificial viscosity.  However, the entropy conservative scheme produces a large number of spurious oscillations in the solution.  These are reduced away from the shock under Lax-Friedrichs dissipation, though oscillations still persist around a large neighborhood of the discontinuity.  The Gibbs-type oscillations are most localized under the matrix dissipation flux.  

We note that this experiment also verifies that entropy stable decoupled SBP schemes (including the over-integrated case \cite{chan2017discretely}) are compatible with entropy stable wall boundary conditions.  As far as the authors know, the stable and high order accurate imposition of such boundary conditions for existing GSBP couplings described in \cite{crean2017high} and Section~\ref{sec:gsbpsat} remains an open problem.  

\subsection{Inviscid Taylor-Green vortex}

We conclude by investigating the behavior of entropy stable Gauss collocation schemes for the inviscid Taylor--Green vortex \cite{ae1937mechanism, gassner2016split, crean2018entropy}.  This problem is posed on the periodic box $[-\pi,\pi]^3$, with initial conditions 
\begin{align*}
\rho &= 1\\
u &= \sin(x_1)\cos(x_2)\cos(x_3),\\
v &= -\cos(x_1)\sin(x_2)\cos(x_3),\\ 
w &= 0,\\
p &= \frac{100}{\gamma} + \frac{1}{16} \LRp{\cos(2x_1) + \cos(2x_2)}\LRp{2+\cos(2x_3)}.
\end{align*}
The Taylor--Green vortex is used to study the transition and decay of turbulence \cite{debonis2013solutions}.  In the absence of viscosity, the Taylor--Green vortex develops successively smaller scales as time increases.  As a result, the solution is guaranteed to contain under-resolved features after a sufficiently large time.  We study the evolution of the kinetic energy $\kappa(t)$ 
\[
\kappa(t) =\frac{1}{\LRb{\Omega}} \int_{\Omega} \rho \bm{u}\cdot\bm{u} \diff{\bm{x}},
\]
as well as the kinetic energy dissipation rate $-\pd{\kappa}{t}$, which is approximated by differencing $\kappa(t)$.  

\begin{figure}
\centering
\subfloat[GLL collocation]{
\begin{tikzpicture}
\begin{axis}[
    width=.525\textwidth,
    xlabel={Time $t$},
    ylabel={$-\pd{\kappa}{t}$}, 
%    xmin=.0125, xmax=.75,
    ymin=-.001, ymax=.016,
    legend pos=north east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={Affine, Curved}    
]
\pgfplotsset{
cycle list={{blue}, {red, dashed}}
}

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0,-0)(0.1,-0)(0.2,-1.1e-05)(0.3,-1e-05)(0.4,-1.4e-05)(0.5,-1.6e-05)(0.6,-2.5e-05)(0.7,-1.5e-05)(0.8,-2.8e-05)(0.9,-2.4e-05)(1,-2.6e-05)(1.1,-2.4e-05)(1.2,-3.2e-05)(1.3,-2.1e-05)(1.4,-2.5e-05)(1.5,-2.6e-05)(1.6,-2.1e-05)(1.7,-1.9e-05)(1.8,-2.6e-05)(1.9,-1.1e-05)(2,-2.5e-05)(2.1,-8e-06)(2.2,-2.5e-05)(2.3,-3e-06)(2.4,-2.3e-05)(2.5,-3e-06)(2.6,-1.7e-05)(2.7,-5e-06)(2.8,-1.2e-05)(2.9,-8e-06)(3,1e-06)(3.1,-1.4e-05)(3.2,1.7e-05)(3.3,2e-06)(3.4,3.8e-05)(3.5,5.3e-05)(3.6,0.000105)(3.7,0.000139)(3.8,0.000221)(3.9,0.000276)(4,0.000342)(4.1,0.000419)(4.2,0.000521)(4.3,0.000678)(4.4,0.000837)(4.5,0.000981)(4.6,0.001062)(4.7,0.001087)(4.8,0.00113)(4.9,0.001166)(5,0.001202)(5.1,0.001253)(5.2,0.001359)(5.3,0.001478)(5.4,0.001732)(5.5,0.002089)(5.6,0.002263)(5.7,0.002498)(5.8,0.002994)(5.9,0.003125)(6,0.003437)(6.1,0.004011)(6.2,0.004722)(6.3,0.005376)(6.4,0.006272)(6.5,0.007188)(6.6,0.00777)(6.7,0.007294)(6.8,0.008198)(6.9,0.009458)(7,0.009693)(7.1,0.011262)(7.2,0.010684)(7.3,0.011183)(7.4,0.012658)(7.5,0.013435)(7.6,0.012556)(7.7,0.012895)(7.8,0.012983)(7.9,0.011737)(8,0.011435)(8.1,0.01177)(8.2,0.011534)(8.3,0.011911)(8.4,0.011895)(8.5,0.011791)(8.6,0.011377)(8.7,0.009956)(8.8,0.010736)(8.9,0.011693)(9,0.009853)(9.1,0.009799)(9.2,0.009839)(9.3,0.010534)(9.4,0.010571)(9.5,0.009947)(9.6,0.010718)(9.7,0.011076)(9.8,0.01093)(9.9,0.011329)(10,0.011703)(10.1,0.01164)(10.2,0.012807)(10.3,0.012246)(10.4,0.010467)(10.5,0.010364)(10.6,0.010194)(10.7,0.008977)(10.8,0.009781)(10.9,0.010854)(11,0.010576)(11.1,0.009041)(11.2,0.008563)(11.3,0.007785)(11.4,0.007869)(11.5,0.008274)(11.6,0.008207)(11.7,0.007814)(11.8,0.007557)(11.9,0.00751)(12,0.0082)(12.1,0.007652)(12.2,0.007354)(12.3,0.007167)(12.4,0.007458)(12.5,0.007237)(12.6,0.007162)(12.7,0.006955)(12.8,0.006604)(12.9,0.006469)(13,0.006581)(13.1,0.006469)(13.2,0.00626)(13.3,0.006146)(13.4,0.006075)(13.5,0.00601)(13.6,0.005883)(13.7,0.005825)(13.8,0.005701)(13.9,0.005585)(14,0.005407)(14.1,0.005251)(14.2,0.005187)(14.3,0.005117)(14.4,0.005088)(14.5,0.00498)(14.6,0.004898)(14.7,0.004772)(14.8,0.004717)(14.9,0.004651)(15,0.004603)(15.1,0.004514)(15.2,0.004408)(15.3,0.004296)(15.4,0.004199)(15.5,0.004117)(15.6,0.004069)(15.7,0.003965)(15.8,0.003854)(15.9,0.003777)(16,0.003716)(16.1,0.003633)(16.2,0.003617)(16.3,0.003594)(16.4,0.003547)(16.5,0.003478)(16.6,0.003385)(16.7,0.003317)(16.8,0.003279)(16.9,0.003207)(17,0.003162)(17.1,0.003144)(17.2,0.003097)(17.3,0.00307)(17.4,0.003008)(17.5,0.002939)(17.6,0.00292)(17.7,0.002873)(17.8,0.002805)(17.9,0.002742)(18,0.00271)(18.1,0.00266)(18.2,0.002629)(18.3,0.002588)(18.4,0.002547)(18.5,0.002515)(18.6,0.002468)(18.7,0.002415)(18.8,0.002386)(18.9,0.002366)(19,0.002338)(19.1,0.002301)(19.2,0.002265)(19.3,0.002243)(19.4,0.002204)(19.5,0.002174)(19.6,0.002139)(19.7,0.002107)(19.8,0.002075)(19.9,0.002052)(20,0.00202)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0,-0)(0.1,-0)(0.2,-1.1e-05)(0.3,-1e-05)(0.4,-1.3e-05)(0.5,-1.6e-05)(0.6,-2.5e-05)(0.7,-1.6e-05)(0.8,-2.8e-05)(0.9,-2.5e-05)(1,-2.5e-05)(1.1,-2.4e-05)(1.2,-3.1e-05)(1.3,-2.2e-05)(1.4,-2.4e-05)(1.5,-2.7e-05)(1.6,-2.1e-05)(1.7,-1.9e-05)(1.8,-2.6e-05)(1.9,-1.2e-05)(2,-2.5e-05)(2.1,-8e-06)(2.2,-2.6e-05)(2.3,-2e-06)(2.4,-2.4e-05)(2.5,-3e-06)(2.6,-1.8e-05)(2.7,-4e-06)(2.8,-1.5e-05)(2.9,-5e-06)(3,-3e-06)(3.1,-1.4e-05)(3.2,1.1e-05)(3.3,-5e-06)(3.4,2.5e-05)(3.5,3.2e-05)(3.6,7.1e-05)(3.7,9e-05)(3.8,0.000156)(3.9,0.000201)(4,0.000279)(4.1,0.000375)(4.2,0.00051)(4.3,0.000691)(4.4,0.000864)(4.5,0.001022)(4.6,0.00114)(4.7,0.001224)(4.8,0.001302)(4.9,0.001404)(5,0.001526)(5.1,0.001685)(5.2,0.001869)(5.3,0.002032)(5.4,0.002409)(5.5,0.002752)(5.6,0.003089)(5.7,0.003588)(5.8,0.004093)(5.9,0.004445)(6,0.004825)(6.1,0.005375)(6.2,0.005868)(6.3,0.006183)(6.4,0.006331)(6.5,0.006797)(6.6,0.007712)(6.7,0.008319)(6.8,0.00896)(6.9,0.009326)(7,0.009777)(7.1,0.010393)(7.2,0.010403)(7.3,0.010421)(7.4,0.010724)(7.5,0.011246)(7.6,0.011484)(7.7,0.011616)(7.8,0.012531)(7.9,0.012689)(8,0.012545)(8.1,0.012473)(8.2,0.012667)(8.3,0.012824)(8.4,0.012941)(8.5,0.0127)(8.6,0.012743)(8.7,0.012718)(8.8,0.012434)(8.9,0.011995)(9,0.011842)(9.1,0.01197)(9.2,0.011787)(9.3,0.011592)(9.4,0.011345)(9.5,0.010925)(9.6,0.011148)(9.7,0.01112)(9.8,0.010876)(9.9,0.010962)(10,0.010975)(10.1,0.010899)(10.2,0.010607)(10.3,0.010373)(10.4,0.01008)(10.5,0.009831)(10.6,0.009418)(10.7,0.009322)(10.8,0.009141)(10.9,0.009067)(11,0.009091)(11.1,0.008885)(11.2,0.008732)(11.3,0.008681)(11.4,0.008587)(11.5,0.008343)(11.6,0.008185)(11.7,0.008042)(11.8,0.008009)(11.9,0.007849)(12,0.007513)(12.1,0.007208)(12.2,0.007146)(12.3,0.007062)(12.4,0.007009)(12.5,0.006919)(12.6,0.006761)(12.7,0.006594)(12.8,0.006558)(12.9,0.00642)(13,0.00625)(13.1,0.006121)(13.2,0.006015)(13.3,0.00599)(13.4,0.00586)(13.5,0.005745)(13.6,0.005636)(13.7,0.005559)(13.8,0.005431)(13.9,0.005396)(14,0.005265)(14.1,0.0052)(14.2,0.005097)(14.3,0.004995)(14.4,0.004901)(14.5,0.004814)(14.6,0.0047)(14.7,0.004622)(14.8,0.004574)(14.9,0.004471)(15,0.004354)(15.1,0.004272)(15.2,0.00426)(15.3,0.004171)(15.4,0.004091)(15.5,0.004049)(15.6,0.003979)(15.7,0.003897)(15.8,0.003842)(15.9,0.003795)(16,0.003726)(16.1,0.003677)(16.2,0.003605)(16.3,0.003528)(16.4,0.003477)(16.5,0.003454)(16.6,0.003389)(16.7,0.003346)(16.8,0.003298)(16.9,0.003229)(17,0.003182)(17.1,0.003154)(17.2,0.003085)(17.3,0.003019)(17.4,0.002948)(17.5,0.002911)(17.6,0.002874)(17.7,0.002836)(17.8,0.002812)(17.9,0.002746)(18,0.0027)(18.1,0.002667)(18.2,0.002635)(18.3,0.002613)(18.4,0.002582)(18.5,0.002542)(18.6,0.002495)(18.7,0.002458)(18.8,0.002435)(18.9,0.002405)(19,0.002376)(19.1,0.002342)(19.2,0.002314)(19.3,0.002278)(19.4,0.00225)(19.5,0.00221)(19.6,0.002181)(19.7,0.002155)(19.8,0.002114)(19.9,0.002085)(20,0.002057)};

\end{axis}
\end{tikzpicture}
}
\subfloat[Gauss collocation]{
\begin{tikzpicture}
\begin{axis}[
    width=.525\textwidth,
    xlabel={Time $t$},
    ymin=-.001, ymax=.016,    
    legend pos=north east, legend cell align=left, legend style={font=\tiny},	
    xmajorgrids=true, ymajorgrids=true, grid style=dashed,
    legend entries={Affine, Curved}    
]
\pgfplotsset{
cycle list={{blue}, {red, dashed}}
}

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0,-0)(0.1,-0)(0.2,-1.1e-05)(0.3,-1e-05)(0.4,-1.4e-05)(0.5,-1.6e-05)(0.6,-2.5e-05)(0.7,-1.5e-05)(0.8,-2.8e-05)(0.9,-2.4e-05)(1,-2.6e-05)(1.1,-2.4e-05)(1.2,-3.2e-05)(1.3,-2.1e-05)(1.4,-2.5e-05)(1.5,-2.6e-05)(1.6,-2.1e-05)(1.7,-1.9e-05)(1.8,-2.6e-05)(1.9,-1.1e-05)(2,-2.5e-05)(2.1,-8e-06)(2.2,-2.5e-05)(2.3,-3e-06)(2.4,-2.3e-05)(2.5,-3e-06)(2.6,-1.7e-05)(2.7,-5e-06)(2.8,-1.2e-05)(2.9,-8e-06)(3,0)(3.1,-1.4e-05)(3.2,1.6e-05)(3.3,2e-06)(3.4,3.8e-05)(3.5,5.5e-05)(3.6,0.000113)(3.7,0.000157)(3.8,0.000259)(3.9,0.000347)(4,0.000462)(4.1,0.00061)(4.2,0.000794)(4.3,0.001034)(4.4,0.001274)(4.5,0.001479)(4.6,0.001593)(4.7,0.001646)(4.8,0.001711)(4.9,0.001762)(5,0.001796)(5.1,0.001797)(5.2,0.001863)(5.3,0.00193)(5.4,0.002103)(5.5,0.002362)(5.6,0.002622)(5.7,0.002965)(5.8,0.0034)(5.9,0.003864)(6,0.004146)(6.1,0.004136)(6.2,0.004996)(6.3,0.005703)(6.4,0.007004)(6.5,0.008301)(6.6,0.009652)(6.7,0.010951)(6.8,0.011407)(6.9,0.013516)(7,0.013684)(7.1,0.014113)(7.2,0.013742)(7.3,0.013059)(7.4,0.014071)(7.5,0.013728)(7.6,0.012821)(7.7,0.012544)(7.8,0.013137)(7.9,0.01424)(8,0.0126)(8.1,0.012763)(8.2,0.012715)(8.3,0.013327)(8.4,0.014155)(8.5,0.013513)(8.6,0.01272)(8.7,0.012531)(8.8,0.013325)(8.9,0.013302)(9,0.013029)(9.1,0.012178)(9.2,0.012225)(9.3,0.013543)(9.4,0.014134)(9.5,0.013937)(9.6,0.012882)(9.7,0.012053)(9.8,0.013117)(9.9,0.012565)(10,0.012059)(10.1,0.011629)(10.2,0.011937)(10.3,0.012583)(10.4,0.012349)(10.5,0.011896)(10.6,0.012309)(10.7,0.011838)(10.8,0.011069)(10.9,0.01059)(11,0.009978)(11.1,0.01026)(11.2,0.010219)(11.3,0.010047)(11.4,0.009645)(11.5,0.009094)(11.6,0.008931)(11.7,0.009278)(11.8,0.009438)(11.9,0.008792)(12,0.008361)(12.1,0.00806)(12.2,0.007456)(12.3,0.007163)(12.4,0.007304)(12.5,0.007684)(12.6,0.00785)(12.7,0.007487)(12.8,0.007027)(12.9,0.006911)(13,0.006836)(13.1,0.00682)(13.2,0.006961)(13.3,0.006948)(13.4,0.006935)(13.5,0.007177)(13.6,0.007091)(13.7,0.006754)(13.8,0.006527)(13.9,0.006203)(14,0.006094)(14.1,0.005863)(14.2,0.005841)(14.3,0.005897)(14.4,0.005707)(14.5,0.005541)(14.6,0.005396)(14.7,0.00524)(14.8,0.005027)(14.9,0.004758)(15,0.004552)(15.1,0.00432)(15.2,0.00422)(15.3,0.004206)(15.4,0.004258)(15.5,0.004133)(15.6,0.003853)(15.7,0.003705)(15.8,0.003694)(15.9,0.003643)(16,0.003556)(16.1,0.003453)(16.2,0.003301)(16.3,0.003159)(16.4,0.003127)(16.5,0.003173)(16.6,0.003171)(16.7,0.003147)(16.8,0.003069)(16.9,0.002928)(17,0.002782)(17.1,0.00268)(17.2,0.00265)(17.3,0.002667)(17.4,0.002667)(17.5,0.00264)(17.6,0.002643)(17.7,0.002728)(17.8,0.002793)(17.9,0.002758)(18,0.002614)(18.1,0.00245)(18.2,0.002369)(18.3,0.002311)(18.4,0.002249)(18.5,0.002216)(18.6,0.002239)(18.7,0.002253)(18.8,0.002197)(18.9,0.002097)(19,0.002026)(19.1,0.00198)(19.2,0.001938)(19.3,0.001898)(19.4,0.001831)(19.5,0.001766)(19.6,0.001727)(19.7,0.001723)(19.8,0.001719)(19.9,0.001707)(20,0.001698)};

\addplot+[semithick, mark options={solid, fill=markercolor}]
coordinates{(0,-0)(0.1,-0)(0.2,-1.1e-05)(0.3,-1e-05)(0.4,-1.3e-05)(0.5,-1.6e-05)(0.6,-2.5e-05)(0.7,-1.6e-05)(0.8,-2.8e-05)(0.9,-2.5e-05)(1,-2.5e-05)(1.1,-2.4e-05)(1.2,-3.1e-05)(1.3,-2.2e-05)(1.4,-2.4e-05)(1.5,-2.7e-05)(1.6,-2.1e-05)(1.7,-1.9e-05)(1.8,-2.6e-05)(1.9,-1.2e-05)(2,-2.5e-05)(2.1,-8e-06)(2.2,-2.6e-05)(2.3,-2e-06)(2.4,-2.4e-05)(2.5,-3e-06)(2.6,-1.8e-05)(2.7,-3e-06)(2.8,-1.4e-05)(2.9,-5e-06)(3,-2e-06)(3.1,-1.3e-05)(3.2,1.3e-05)(3.3,-2e-06)(3.4,3.1e-05)(3.5,4.2e-05)(3.6,8.7e-05)(3.7,0.000117)(3.8,0.000203)(3.9,0.000272)(4,0.000381)(4.1,0.000525)(4.2,0.000714)(4.3,0.000946)(4.4,0.001174)(4.5,0.001385)(4.6,0.001526)(4.7,0.001622)(4.8,0.001724)(4.9,0.001872)(5,0.002067)(5.1,0.002293)(5.2,0.002575)(5.3,0.002922)(5.4,0.003262)(5.5,0.003483)(5.6,0.003769)(5.7,0.004017)(5.8,0.004277)(5.9,0.004577)(6,0.005016)(6.1,0.005492)(6.2,0.006201)(6.3,0.006815)(6.4,0.007136)(6.5,0.008004)(6.6,0.008172)(6.7,0.008672)(6.8,0.009029)(6.9,0.009603)(7,0.010511)(7.1,0.010773)(7.2,0.01077)(7.3,0.011114)(7.4,0.011948)(7.5,0.012385)(7.6,0.012737)(7.7,0.012609)(7.8,0.013135)(7.9,0.0134)(8,0.01394)(8.1,0.014723)(8.2,0.014402)(8.3,0.01389)(8.4,0.013833)(8.5,0.014437)(8.6,0.014767)(8.7,0.014866)(8.8,0.014848)(8.9,0.014442)(9,0.014686)(9.1,0.014743)(9.2,0.014514)(9.3,0.013853)(9.4,0.013283)(9.5,0.013316)(9.6,0.013374)(9.7,0.013275)(9.8,0.013436)(9.9,0.013322)(10,0.012779)(10.1,0.01246)(10.2,0.012098)(10.3,0.011781)(10.4,0.011687)(10.5,0.011505)(10.6,0.011334)(10.7,0.011239)(10.8,0.010745)(10.9,0.010255)(11,0.010106)(11.1,0.009861)(11.2,0.009627)(11.3,0.009393)(11.4,0.009309)(11.5,0.009199)(11.6,0.00884)(11.7,0.00852)(11.8,0.008338)(11.9,0.008167)(12,0.008026)(12.1,0.007844)(12.2,0.007667)(12.3,0.007473)(12.4,0.007233)(12.5,0.007066)(12.6,0.006955)(12.7,0.00674)(12.8,0.006575)(12.9,0.006464)(13,0.006253)(13.1,0.005983)(13.2,0.005785)(13.3,0.005656)(13.4,0.005644)(13.5,0.005576)(13.6,0.005468)(13.7,0.005338)(13.8,0.005177)(13.9,0.004984)(14,0.004959)(14.1,0.004922)(14.2,0.004777)(14.3,0.004656)(14.4,0.004532)(14.5,0.004364)(14.6,0.004265)(14.7,0.004247)(14.8,0.004179)(14.9,0.004047)(15,0.003934)(15.1,0.003867)(15.2,0.003779)(15.3,0.003693)(15.4,0.003662)(15.5,0.003621)(15.6,0.003529)(15.7,0.003449)(15.8,0.003409)(15.9,0.003362)(16,0.003323)(16.1,0.003276)(16.2,0.003213)(16.3,0.003145)(16.4,0.003069)(16.5,0.003003)(16.6,0.00294)(16.7,0.002864)(16.8,0.002815)(16.9,0.002753)(17,0.002676)(17.1,0.002615)(17.2,0.002597)(17.3,0.002599)(17.4,0.002565)(17.5,0.002509)(17.6,0.002445)(17.7,0.002379)(17.8,0.002328)(17.9,0.002295)(18,0.002251)(18.1,0.002218)(18.2,0.002207)(18.3,0.002183)(18.4,0.002146)(18.5,0.002114)(18.6,0.002093)(18.7,0.002071)(18.8,0.002029)(18.9,0.001986)(19,0.001957)(19.1,0.001951)(19.2,0.001951)(19.3,0.001943)(19.4,0.001932)(19.5,0.001914)(19.6,0.001889)(19.7,0.001859)(19.8,0.001846)(19.9,0.001833)(20,0.001798)};
\end{axis}
\end{tikzpicture}
}
\caption{Kinetic energy dissipation rate for entropy stable GLL and Gauss collocation schemes with $N=7$ and $h = \pi/8$. }
\label{fig:tgv}
\end{figure}

Figure~\ref{fig:tgv} shows the evolution of the kinetic energy dissipation rate from $t\in [0,20]$ for Gauss and GLL collocation schemes on affine and curved meshes.  The curved meshes used here are constructed by modifying nodal positions through the mapping
\[
\tilde{\bm{x}} = \bm{x} + \frac{1}{2}\sin(x)\sin(y)\sin(z).
\]
All cases utilize $N=7$ and $h = \pi/8$ (corresponding to $8$ elements per side), as well as a CFL of $.25$.  Lax-Friedrichs dissipation is used for all simulations.  For both affine and curved meshes, the presented Gauss collocation schemes remain stable in the presence of highly under-resolved solution features.  Kinetic energy dissipation rates for both GLL and Gauss collocation are qualitatively similar and are consistent with existing results in the literature for the inviscid Taylor-Green vortex \cite{gassner2016split,chan2018discretely}.  


\section{A theoretical cost comparison}

While the numerical experiments presented in previous sections demonstrate several advantages of Gauss collocation methods over GLL collocation schemes, these do not account for additional costs associated with Gauss collocation schemes.  While a detailed time-to-solution comparison is outside of the scope of this work, we can compare computational costs associated with Gauss, staggered-grid, and GLL collocation schemes.  

The main computational costs associated with entropy stable schemes are volume operations, which include evaluations of two-point fluxes and applications of one-dimensional differentiation and interpolation matrices.  We do not count inter-element communication or flux computations, as these are typically less expensive than volume operations (especially for higher polynomial degrees).  In three dimensions, a degree $N$ GLL collocation scheme contains $(N+1)^3$ nodes.  Two-point fluxes are computed between states at one node and states at $(N+1)$ additional nodes, resulting in a total of $(N+1)^4$ two-point flux evaluations in each dimension.  For a staggered grid scheme, two-point fluxes are computed on a degree $(N+1)$ GLL grid consisting of $(N+2)^3$ nodes, resulting in $(N+2)^4$ flux evaluations per dimension.  

Gauss collocation schemes compute two-point fluxes on a grid of Gauss nodes, resulting in $(N+1)^4$ flux evaluations.  However, one must also evaluate two-point fluxes between face nodes and volume nodes, and vice versa.  Specifically, Gauss schemes perform two evaluations of two-point fluxes between each face node and the line of $(N+1)$ volume nodes normal to that face, resulting in an extra $4(N+1)^3$ flux evaluations per dimension.  Because these flux evaluations correspond to the computation of $\bm{Q}^i_N\circ \bm{F}_S$, one can also exploit the skew symmetric nature of the off-diagonal blocks of $\bm{Q}^i_N$ to reduce the number of two-point flux evaluations to $2(N+1)^3$.  

We also consider costs associated with applying operator matrices.  GLL collocation schemes require applying a one-dimensional differentiation matrix in each dimension, resulting in $O\LRp{(N+1)^4}$ operations per dimension in 3D.  Staggered-grid schemes require $O\LRp{(N+2)^4}$ operations per dimension (corresponding to differentiation on a degree $(N+1)$ GLL grid) as well as $O\LRp{2(N+2)(N+1)^3}$ operations required for interpolation to and from a $(N+1)$ point Gauss grid to a $(N+2)$ point GLL grid in three dimensions.  Gauss collocation schemes require only interpolation to and from face points, resulting in an additional $O\LRp{2(N+1)^3}$ operations per dimension per element.  

\begin{figure}
\centering
\subfloat[Two-point flux evaluations]{
\begin{tikzpicture}
\begin{axis}[
	width=.525\textwidth,
	legend cell align=left,
	xlabel={Degree $N$},
%	ylabel={Number of flux computations},
	xmin=.5, xmax=7.5,
%	ymin=0,ymax=7,
%	ybar stacked,
             ybar=2*\pgflinewidth,
	bar width=2.5pt,
%	nodes near coords,
	%xmin=.5, xmax=9.5,
	xtick={1,2,3,4,5,6,7},
	legend pos=north west,
	xmajorgrids=true,
	ymajorgrids=true,
	grid style=dashed,
] 
%nodal runtimes
\addplot coordinates{(1,48)(2,243)(3,768)(4,1875)(5,3888)(6,7203)(7,12288)};
\addplot coordinates{(1,243)(2,768)(3,1875)(4,3888)(5,7203)(6,12288)(7,19683)};
\addplot coordinates{(1,144)(2,567)(3,1536)(4,3375)(5,6480)(6,11319)(7,18432)};
\addplot coordinates{(1,96)(2,405)(3,1152)(4,2625)(5,5184)(6,9261)(7,15360)};
\legend{GLL, Staggered, Gauss, Gauss (w/sym.)}
\end{axis}
\end{tikzpicture}
}
\subfloat[Matrix computation operations]{
\begin{tikzpicture}
\begin{axis}[
	width=.525\textwidth,
	legend cell align=left,
%	title={Node-per-thread (NPT) nodal},
	xlabel={Degree $N$},
%	ylabel={Runtime (s)},
	xmin=.5, xmax=7.5,
%	ymin=0,ymax=7,
             ybar=2*\pgflinewidth,
	bar width=4pt,             
	xtick={1,2,3,4,5,6,7},
	legend pos=north west,
	xmajorgrids=true,
	ymajorgrids=true,
	grid style=dashed,
] 
%nodal runtimes
\addplot coordinates{(1,96)(2,486)(3,1536)(4,3750)(5,7776)(6,14406)(7,24576)};
\addplot coordinates{(1,582)(2,1968)(3,5030)(4,10776)(5,20454)(6,35552)(7,57798)};
\addplot coordinates{(1,192)(2,810)(3,2304)(4,5250)(5,10368)(6,18522)(7,30720)};

\legend{GLL, Staggered, Gauss}

\end{axis}
\end{tikzpicture}}
\caption{Comparison of GLL, staggered grid, and Gauss collocation schemes in terms of number of two-point flux evaluations and operations associated with matrix computations. }
\label{fig:cost}
\end{figure}

Figure~\ref{fig:cost} shows the estimated number of two-point flux evaluations and matrix operations for GLL, staggered grid, and Gauss collocation schemes in three dimensions.  We observe that a straightforward implementation of Gauss collocation does not significantly reduce the number of flux evaluations compared to staggered grid schemes, though this can be improved by exploiting symmetry in the off-diagonal blocks of the decoupled SBP operator.  Gauss collocation schemes see a much more significant gain over staggered grid schemes in terms of matrix computations.  

We note that the number of two-point flux evaluations and matrix operations will impact runtime differently depending on the implementation and computational architecture.  For example, while flux evaluations typically dominate runtimes for serial CPU implementations at all orders of approximation, they do not contribute significantly to runtimes at polynomial degrees $N=1,\ldots, 8$ for implementations on Graphics Processing Units (GPUs)  \cite{wintermeyer2018entropy}.  

\section{Conclusion}

This work shows how to construct efficient entropy stable high order Gauss collocation DG schemes on quadrilateral and hexahedral meshes.  Key to the construction of efficient methods are decoupled SBP operators, which deliver entropy stability and high order accuracy while maintaining compact inter-element coupling terms.  These operators are also compatible with existing entropy stable methods for applying interface dissipation \cite{winters2017uniquely} or imposing boundary conditions.  Numerical experiments demonstrate both the stability and high order accuracy of the proposed Gauss collocation schemes on both affine and curvilinear meshes.  

We note that results for Gauss collocation are similar to those attained by entropy stable staggered-grid schemes \cite{parsani2016entropy}.  However, Gauss collocation schemes result in a lower number of two-point flux evaluations and floating point operations from matrix computations compared to staggered-grid methods.  While a rigorous computational comparison between GLL and Gauss collocation schemes remains to be done, Gauss collocation schemes show significant improvements in accuracy compared to GLL collocation schemes on non-Cartesian meshes.  In particular, for sufficiently warped curvilinear mappings, degree $N$ Gauss collocation schemes achieve an accuracy comparable to degree $(N+1)$ GLL collocation schemes in two and three dimensions.  

\section{Acknowledgments}

Jesse Chan is supported by NSF DMS-1719818 and DMS-1712639.  

\appendix

\section{Decoupled SBP operators for general choices of quadrature and basis}
\label{app:decoupled}

For general choices of quadrature and basis, decoupled projection operators involve a volume quadrature interpolation matrix $\bm{V}_q$, a face quadrature interpolation matrix $\bm{V}_f$, and a quadrature-based $L^2$ projection matrix $\bm{P}_q$.  Let $\LRc{\phi_j}_{j=1}^{N_p}$ denote a set of $N_p$ basis functions, and let $\LRc{\bm{x}_i, \bm{w}_i}_{i = 1}^{N_q}$ denote a set of $N_q$ volume quadrature points and weights in $d$ dimensions.  
Then, $\bm{V}_q, \bm{V}_f$ are given as 
\begin{align*}
\LRp{\bm{V}_q}_{ij} &= \phi_j(\bm{x}_i), \quad 1 \leq i,j \leq N_q,\\
\LRp{\bm{V}_f}_{ij} &= \phi_j\LRp{\bm{x}^f_i}, \quad 1 \leq i \leq N_q, \quad 1\leq j \leq N^f_q.
\end{align*}
These matrices can be used to define the quadrature-based $L^2$ projection matrix $\bm{P}_q$.  Let $\bm{W}$ denote the diagonal matrix of quadrature weights.  Then, 
\[
\bm{M} = \bm{V}_q^T\bm{W}\bm{V}_q, \qquad \bm{P}_q = \bm{M}^{-1}\bm{V}_q^T\bm{W}.  
\]
Let $\bm{D}^i$ now denote a modal differentiation matrix with respect to the $i$th coordinate, which maps coefficients in the basis $\phi_j$ to coefficients of the $i$th derivative.  By composing this matrix with interpolation and projection matrices, one can define differencing operators $\bm{D}_q^i = \bm{V}_q\bm{D}^i\bm{P}_q$ which map values at quadrature points to values of approximate derivatives at quadrature points. It was shown in \cite{chan2017discretely} that $\bm{Q}^i = \bm{W}\bm{D}_q^i$ satisfies a generalized SBP property involving the face interpolation and projection matrices $\bm{V}_f, \bm{P}_q$.  

The decoupled SBP operator $\bm{Q}_N^i$ is then given as
\begin{equation}
\bm{Q}_N^i = \begin{bmatrix}
\bm{Q}^i - \frac{1}{2}\LRp{\bm{V}_f\bm{P}_q}^T\bm{W}_f \diag{\bm{n}_i}{\bm{V}_f\bm{P}_q} & \frac{1}{2}\LRp{\bm{V}_f\bm{P}_q}^T\bm{W}_f \diag{\bm{n}_i}\\
-\frac{1}{2}\bm{W}_f \diag{\bm{n}_i}{\bm{V}_f\bm{P}_q} & \frac{1}{2}\bm{W}_f \diag{\bm{n}_i}
\end{bmatrix}.
\label{eq:qni_quad}
\end{equation}
A straightforward computation shows that $\bm{Q}_N^i$ satisfies an SBP property \cite{chan2017discretely}.  
%\[
%\bm{Q}_N^i + \LRp{\bm{Q}_N^i}^T = \begin{bmatrix}\bm{0} &\\
%& \bm{W}_f \diag{\bm{n}_i}\end{bmatrix}.
%\]
It is worth noting that the form of $\bm{Q}_N^i$ does not depend on the choice of basis.  So long as the approximation space spanned by the basis $\phi_j$ does not change, the domain and range of $\bm{Q}_N^i$ depend solely on the choice of volume and surface quadrature points.  

A collocation scheme assumes that the number of quadrature points is identical to the number of basis functions.  If the solution is represented using degree $N$ Lagrange polynomials at quadrature points, the matrices $\bm{V}_q, \bm{P}_q$ simplify to
\[
\LRp{\bm{V}_q}_{ij} = \delta_{ij}, \qquad \bm{M} = \bm{W}, \qquad \bm{P}_q = \bm{M}^{-1}\bm{V}_q^T\bm{W} = \bm{I}.
\]
Plugging these simplifications into (\ref{eq:qni_quad}) and restricting to one spatial dimension recovers the decoupled SBP operator (\ref{eq:qndef}).
%In summary, the collocation assumption removes the need to interpolate to and from a polynomial space to volume quadrature points within an entropy stable scheme.

%\note{Todo: add.}

\bibliographystyle{unsrt}
\bibliography{dg}


\end{document}


